<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Wood Construction</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            user-select: none;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        #canvas.grabbing {
            cursor: grabbing;
        }
        
        /* Material Selection Panel */
        .material-panel {
            position: fixed;
            left: 20px;
            top: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            width: 200px;
        }
        
        .material-panel h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #333;
        }
        
        .thickness-group {
            margin-bottom: 15px;
        }
        
        .thickness-group h4 {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .wood-option {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background: #f5f5f5;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        
        .wood-option:hover {
            background: #e8e8e8;
            transform: translateX(2px);
        }
        
        .wood-option.active {
            background: #e3f2fd;
            border-color: #2196f3;
        }
        
        .wood-icon {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fff;
        }
        
        .wood-label {
            font-size: 12px;
            font-weight: 500;
        }
        
        /* Project Controls */
        .project-panel {
            position: fixed;
            right: 20px;
            top: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            width: 200px;
        }
        
        .project-panel h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #333;
        }
        
        .project-list {
            margin-bottom: 10px;
        }
        
        .project-item {
            padding: 8px;
            margin: 4px 0;
            background: #f5f5f5;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .project-item:hover {
            background: #e8e8e8;
        }
        
        .project-item.active {
            background: #e3f2fd;
            font-weight: 500;
        }
        
        .project-item button {
            padding: 2px 6px;
            font-size: 10px;
            background: #ff5252;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .project-controls button {
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .project-controls button:hover {
            background: #1976d2;
        }
        
        /* Hotkey Guide */
        .hotkey-guide {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 11px;
            transition: opacity 0.3s;
        }
        
        .hotkey-guide.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .hotkey-group {
            margin-bottom: 10px;
        }
        
        .hotkey-group h4 {
            font-size: 12px;
            margin-bottom: 5px;
            color: #4fc3f7;
        }
        
        .hotkey {
            display: flex;
            margin: 3px 0;
        }
        
        .hotkey-key {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 8px;
            font-family: monospace;
            min-width: 20px;
            text-align: center;
        }
        
        /* Measurement Display */
        .measurement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        
        .measurement.hidden {
            opacity: 0;
        }
        
        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading 3D environment...</div>
    <canvas id="canvas"></canvas>
    
    <!-- Material Selection Panel -->
    <div class="material-panel" id="materialPanel">
        <h3>Wood Materials</h3>
        <div id="materialList"></div>
    </div>
    
    <!-- Project Panel -->
    <div class="project-panel">
        <h3>Projects</h3>
        <div class="project-list" id="projectList"></div>
        <div class="project-controls">
            <button onclick="app.createNewProject()">New Project</button>
            <button onclick="app.renameProject()">Rename</button>
        </div>
    </div>
    
    <!-- Hotkey Guide -->
    <div class="hotkey-guide" id="hotkeyGuide">
        <div class="hotkey-group" id="activeGuide" style="display: none;">
            <h4>Active Piece</h4>
            <div class="hotkey"><span class="hotkey-key">Z</span> Move along Z axis</div>
            <div class="hotkey"><span class="hotkey-key">X</span> Move along X axis</div>
            <div class="hotkey"><span class="hotkey-key">C</span> Move along Y axis</div>
            <div class="hotkey"><span class="hotkey-key">V</span> + Click end to adjust length</div>
            <div class="hotkey"><span class="hotkey-key">A</span> Rotate around Z</div>
            <div class="hotkey"><span class="hotkey-key">S</span> Rotate around X</div>
            <div class="hotkey"><span class="hotkey-key">D</span> Rotate around Y</div>
            <div class="hotkey"><span class="hotkey-key">Backspace</span> Cancel</div>
        </div>
        <div class="hotkey-group" id="selectedGuide" style="display: none;">
            <h4>Selected Pieces</h4>
            <div class="hotkey"><span class="hotkey-key">E</span> + Click to duplicate</div>
            <div class="hotkey"><span class="hotkey-key">T</span> Delete selected</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl</span> + Click to multi-select</div>
        </div>
        <div class="hotkey-group" id="generalGuide">
            <h4>General</h4>
            <div class="hotkey"><span class="hotkey-key">Left Click</span> Pan camera</div>
            <div class="hotkey"><span class="hotkey-key">Right Click</span> Orbit camera</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl+Z</span> Undo</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl+Y</span> Redo</div>
            <div class="hotkey"><span class="hotkey-key">1-0</span> Quick material select</div>
        </div>
    </div>
    
    <!-- Measurement Display -->
    <div class="measurement hidden" id="measurement"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global app object
        const app = {
            scene: null,
            camera: null,
            renderer: null,
            raycaster: new THREE.Raycaster(),
            mouse: new THREE.Vector2(),
            
            // State
            activePiece: null,
            selectedPieces: new Set(),
            movementAxis: null,
            isLengthEditing: false,
            lengthEditFace: null,
            
            // Input state
            keys: {},
            mouseDown: false,
            rightMouseDown: false,
            lastMouseX: 0,
            lastMouseY: 0,
            
            // Wood dimensions (thickness x width in mm)
            woodDimensions: [
                // Group by thickness
                { thickness: 20, widths: [48, 73, 98, 120] },
                { thickness: 28, widths: [48, 73, 98, 120] },
                { thickness: 36, widths: [48, 73, 98, 120] },
                { thickness: 48, widths: [48, 73, 98, 120] },
                { thickness: 98, widths: [48, 73, 98, 120] }
            ],
            
            selectedDimension: null,
            recentDimensions: [],
            
            // Project management
            projects: {},
            currentProject: null,
            
            // Undo/Redo
            undoStack: [],
            redoStack: [],
            
            // Visual helpers
            snapLine: null,
            measurementTimeout: null
        };
        
        // Initialize the application
        function init() {
            // Setup Three.js
            app.scene = new THREE.Scene();
            app.scene.background = new THREE.Color(0xf0f0f0);
            
            // Camera setup (Z is up)
            app.camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            app.camera.position.set(2, -2, 2);
            app.camera.lookAt(0, 0, 0);
            
            // Renderer
            const canvas = document.getElementById('canvas');
            app.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            app.renderer.setSize(window.innerWidth, window.innerHeight);
            app.renderer.shadowMap.enabled = true;
            app.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            app.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(5, -5, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            app.scene.add(directionalLight);
            
            // Ground plane
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xe0e0e0,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal (Z-up system)
            ground.receiveShadow = true;
            ground.userData.isGround = true;
            app.scene.add(ground);
            
            // Grid helper (adjusted for Z-up)
            const gridHelper = new THREE.GridHelper(20, 40, 0x888888, 0xcccccc);
            gridHelper.rotation.x = Math.PI / 2;
            app.scene.add(gridHelper);
            
            // Initialize UI
            initializeMaterialPanel();
            loadProjects();
            
            // Event listeners
            setupEventListeners();
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Start render loop
            animate();
        }
        
        // Initialize material selection panel
        function initializeMaterialPanel() {
            const materialList = document.getElementById('materialList');
            
            app.woodDimensions.forEach((group, groupIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'thickness-group';
                
                const groupTitle = document.createElement('h4');
                groupTitle.textContent = `${group.thickness}mm Thickness`;
                groupDiv.appendChild(groupTitle);
                
                group.widths.forEach((width, widthIndex) => {
                    const option = document.createElement('div');
                    option.className = 'wood-option';
                    option.dataset.thickness = group.thickness;
                    option.dataset.width = width;
                    
                    // Create visual icon (1:10 scale)
                    const icon = document.createElement('canvas');
                    icon.className = 'wood-icon';
                    icon.width = 40;
                    icon.height = 40;
                    const ctx = icon.getContext('2d');
                    
                    // Draw cross-section at 1:10 scale
                    const scale = 0.3;
                    const t = group.thickness * scale;
                    const w = width * scale;
                    
                    ctx.fillStyle = '#8B6F47';
                    ctx.fillRect(
                        (40 - t) / 2,
                        (40 - w) / 2,
                        t,
                        w
                    );
                    
                    ctx.strokeStyle = '#6B5637';
                    ctx.strokeRect(
                        (40 - t) / 2,
                        (40 - w) / 2,
                        t,
                        w
                    );
                    
                    const label = document.createElement('div');
                    label.className = 'wood-label';
                    label.textContent = `${group.thickness}Ã—${width}mm`;
                    
                    option.appendChild(icon);
                    option.appendChild(label);
                    
                    option.addEventListener('click', () => selectWoodDimension(group.thickness, width));
                    
                    groupDiv.appendChild(option);
                });
                
                materialList.appendChild(groupDiv);
            });
        }
        
        // Select wood dimension
        function selectWoodDimension(thickness, width) {
            // Update UI
            document.querySelectorAll('.wood-option').forEach(opt => {
                opt.classList.remove('active');
            });
            
            const selected = document.querySelector(
                `.wood-option[data-thickness="${thickness}"][data-width="${width}"]`
            );
            selected.classList.add('active');
            
            app.selectedDimension = { thickness, width };
            
            // Update recent dimensions
            const key = `${thickness}x${width}`;
            app.recentDimensions = app.recentDimensions.filter(d => d !== key);
            app.recentDimensions.unshift(key);
            if (app.recentDimensions.length > 10) {
                app.recentDimensions.pop();
            }
            
            // Create new wood piece
            createWoodPiece(thickness, width);
        }
        
        // Create wood piece
        function createWoodPiece(thickness, width, length = 500) {
            // Cancel current active piece if exists
            if (app.activePiece) {
                app.scene.remove(app.activePiece);
            }
            
            // Convert mm to scene units (1 unit = 1 meter)
            const t = thickness / 1000;
            const w = width / 1000;
            const l = length / 1000;
            
            // Create geometry with rounded edges
            const geometry = new THREE.BoxGeometry(t, w, l);
            const material = new THREE.MeshStandardMaterial({
                color: 0x8B6F47,
                roughness: 0.7,
                metalness: 0.1
            });
            
            const piece = new THREE.Mesh(geometry, material);
            piece.castShadow = true;
            piece.receiveShadow = true;
            
            // Store dimensions in userData
            piece.userData = {
                thickness,
                width,
                length,
                isWoodPiece: true,
                isActive: true
            };
            
            // Position at safe distance from camera
            const direction = new THREE.Vector3();
            app.camera.getWorldDirection(direction);
            piece.position.copy(app.camera.position);
            piece.position.add(direction.multiplyScalar(1));
            piece.position.z = Math.max(piece.position.z, l / 2 + 0.1);
            
            // Add to scene
            app.scene.add(piece);
            app.activePiece = piece;
            
            // Update hotkey guide
            updateHotkeyGuide();
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', onWindowResize);
            
            // Mouse events
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('contextmenu', e => e.preventDefault());
            
            // Keyboard events
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Mouse wheel
            document.addEventListener('wheel', onMouseWheel);
        }
        
        // Window resize handler
        function onWindowResize() {
            app.camera.aspect = window.innerWidth / window.innerHeight;
            app.camera.updateProjectionMatrix();
            app.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Mouse down handler
        function onMouseDown(event) {
            if (event.target.id !== 'canvas') return;
            
            if (event.button === 0) {
                app.mouseDown = true;
                
                // Check for object interaction
                updateMouse(event);
                checkIntersection();
                
            } else if (event.button === 2) {
                app.rightMouseDown = true;
            }
            
            app.lastMouseX = event.clientX;
            app.lastMouseY = event.clientY;
            
            document.getElementById('canvas').classList.add('grabbing');
        }
        
        // Mouse move handler
        function onMouseMove(event) {
            const deltaX = event.clientX - app.lastMouseX;
            const deltaY = event.clientY - app.lastMouseY;
            
            if (app.mouseDown && !app.movementAxis && !app.isLengthEditing) {
                // Camera panning
                const panSpeed = 0.002;
                const right = new THREE.Vector3();
                const up = new THREE.Vector3();
                
                app.camera.getWorldDirection(up);
                right.crossVectors(up, new THREE.Vector3(0, 0, 1)).normalize();
                up.crossVectors(right, up).normalize();
                
                app.camera.position.add(right.multiplyScalar(-deltaX * panSpeed));
                app.camera.position.add(up.multiplyScalar(deltaY * panSpeed));
                
            } else if (app.rightMouseDown) {
                // Camera orbiting
                const orbitSpeed = 0.005;
                const spherical = new THREE.Spherical();
                const offset = app.camera.position.clone();
                
                spherical.setFromVector3(offset);
                spherical.theta -= deltaX * orbitSpeed;
                spherical.phi += deltaY * orbitSpeed;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                app.camera.position.setFromSpherical(spherical);
                app.camera.lookAt(0, 0, 0);
                
            } else if (app.activePiece) {
                // Move active piece
                if (app.movementAxis) {
                    moveAlongAxis(event);
                } else if (app.isLengthEditing) {
                    adjustLength(event);
                }
            }
            
            app.lastMouseX = event.clientX;
            app.lastMouseY = event.clientY;
            
            updateMouse(event);
        }
        
        // Mouse up handler
        function onMouseUp(event) {
            if (event.button === 0) {
                app.mouseDown = false;
                
                if (app.activePiece && !app.movementAxis && !app.isLengthEditing) {
                    // Place the piece
                    placeActivePiece();
                }
                
                app.movementAxis = null;
                app.isLengthEditing = false;
                app.lengthEditFace = null;
                
            } else if (event.button === 2) {
                app.rightMouseDown = false;
            }
            
            document.getElementById('canvas').classList.remove('grabbing');
            
            // Clear snap line
            if (app.snapLine) {
                app.scene.remove(app.snapLine);
                app.snapLine = null;
            }
        }
        
        // Key down handler
        function onKeyDown(event) {
            app.keys[event.key.toLowerCase()] = true;
            
            // Movement axis controls
            if (app.activePiece) {
                if (event.key.toLowerCase() === 'z') {
                    app.movementAxis = 'z';
                } else if (event.key.toLowerCase() === 'x') {
                    app.movementAxis = 'x';
                } else if (event.key.toLowerCase() === 'c') {
                    app.movementAxis = 'y';
                }
                
                // Rotation controls
                if (event.key.toLowerCase() === 'a') {
                    rotatePiece(app.activePiece, 'z');
                } else if (event.key.toLowerCase() === 's') {
                    rotatePiece(app.activePiece, 'x');
                } else if (event.key.toLowerCase() === 'd') {
                    rotatePiece(app.activePiece, 'y');
                }
                
                // Cancel placement
                if (event.key === 'Backspace') {
                    app.scene.remove(app.activePiece);
                    app.activePiece = null;
                    updateHotkeyGuide();
                }
            }
            
            // Selection controls
            if (event.key.toLowerCase() === 't' && app.selectedPieces.size > 0) {
                deleteSelectedPieces();
            }
            
            // Undo/Redo
            if (event.ctrlKey) {
                if (event.key.toLowerCase() === 'z') {
                    event.preventDefault();
                    undo();
                } else if (event.key.toLowerCase() === 'y') {
                    event.preventDefault();
                    redo();
                }
            }
            
            // Quick material selection (1-0 keys)
            const numKey = parseInt(event.key);
            if (!isNaN(numKey) && numKey >= 0 && numKey <= 9) {
                const index = numKey === 0 ? 9 : numKey - 1;
                if (app.recentDimensions[index]) {
                    const [thickness, width] = app.recentDimensions[index].split('x').map(Number);
                    selectWoodDimension(thickness, width);
                }
            }
        }
        
        // Key up handler
        function onKeyUp(event) {
            delete app.keys[event.key.toLowerCase()];
            
            // Clear movement axis when key released
            if (!app.mouseDown) {
                if (event.key.toLowerCase() === 'z' && app.movementAxis === 'z') {
                    app.movementAxis = null;
                } else if (event.key.toLowerCase() === 'x' && app.movementAxis === 'x') {
                    app.movementAxis = null;
                } else if (event.key.toLowerCase() === 'c' && app.movementAxis === 'y') {
                    app.movementAxis = null;
                }
            }
        }
        
        // Mouse wheel handler
        function onMouseWheel(event) {
            const zoomSpeed = 0.001;
            const direction = new THREE.Vector3();
            app.camera.getWorldDirection(direction);
            
            app.camera.position.add(direction.multiplyScalar(-event.deltaY * zoomSpeed));
        }
        
        // Update mouse position
        function updateMouse(event) {
            app.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            app.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        
        // Check for intersections
        function checkIntersection() {
            app.raycaster.setFromCamera(app.mouse, app.camera);
            
            const objects = app.scene.children.filter(obj => 
                obj.userData.isWoodPiece && !obj.userData.isActive
            );
            
            const intersects = app.raycaster.intersectObjects(objects);
            
            if (intersects.length > 0) {
                const piece = intersects[0].object;
                
                if (app.keys['e']) {
                    // Duplicate
                    duplicatePiece(piece);
                } else if (event.ctrlKey) {
                    // Multi-select
                    if (app.selectedPieces.has(piece)) {
                        app.selectedPieces.delete(piece);
                        updatePieceSelection(piece, false);
                    } else {
                        app.selectedPieces.add(piece);
                        updatePieceSelection(piece, true);
                    }
                } else {
                    // Single select
                    clearSelection();
                    app.selectedPieces.add(piece);
                    updatePieceSelection(piece, true);
                }
                
                updateHotkeyGuide();
            }
        }
        
        // Move piece along axis
        function moveAlongAxis(event) {
            if (!app.activePiece || !app.movementAxis) return;
            
            const movementSpeed = 0.001;
            const delta = event.clientX - app.lastMouseX;
            
            const movement = new THREE.Vector3();
            if (app.movementAxis === 'x') {
                movement.x = delta * movementSpeed;
            } else if (app.movementAxis === 'y') {
                movement.y = delta * movementSpeed;
            } else if (app.movementAxis === 'z') {
                movement.z = -delta * movementSpeed;
            }
            
            app.activePiece.position.add(movement);
            
            // Check collisions and snap
            checkCollisionAndSnap();
            
            // Update snap line
            updateSnapLine();
        }
        
        // Check collision and snap
        function checkCollisionAndSnap() {
            if (!app.activePiece) return;
            
            const box = new THREE.Box3().setFromObject(app.activePiece);
            const snapThreshold = 0.01; // 10mm
            
            let hasCollision = false;
            let snapPosition = null;
            let minDistance = Infinity;
            
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece && obj !== app.activePiece) {
                    const targetBox = new THREE.Box3().setFromObject(obj);
                    
                    if (box.intersectsBox(targetBox)) {
                        hasCollision = true;
                        
                        // For vertical movement, allow overlap but show red
                        if (app.movementAxis === 'z') {
                            app.activePiece.material.color.setHex(0xff0000);
                        } else {
                            // Push up to top of collided piece
                            const overlap = box.min.z - targetBox.max.z;
                            if (overlap < 0) {
                                app.activePiece.position.z -= overlap;
                            }
                        }
                    }
                    
                    // Check for snap points
                    if (app.movementAxis) {
                        const corners = getBoxCorners(targetBox);
                        corners.forEach(corner => {
                            const distance = corner[app.movementAxis] - app.activePiece.position[app.movementAxis];
                            if (Math.abs(distance) < snapThreshold && Math.abs(distance) < Math.abs(minDistance)) {
                                minDistance = distance;
                                snapPosition = corner[app.movementAxis];
                            }
                        });
                    }
                }
            });
            
            // Apply snap
            if (snapPosition !== null) {
                app.activePiece.position[app.movementAxis] = snapPosition;
            }
            
            // Reset color if no collision
            if (!hasCollision) {
                app.activePiece.material.color.setHex(0x8B6F47);
            }
            
            // Show measurement
            showMeasurement(minDistance * 1000); // Convert to mm
        }
        
        // Get box corners
        function getBoxCorners(box) {
            return [
                new THREE.Vector3(box.min.x, box.min.y, box.min.z),
                new THREE.Vector3(box.max.x, box.min.y, box.min.z),
                new THREE.Vector3(box.min.x, box.max.y, box.min.z),
                new THREE.Vector3(box.max.x, box.max.y, box.min.z),
                new THREE.Vector3(box.min.x, box.min.y, box.max.z),
                new THREE.Vector3(box.max.x, box.min.y, box.max.z),
                new THREE.Vector3(box.min.x, box.max.y, box.max.z),
                new THREE.Vector3(box.max.x, box.max.y, box.max.z),
                // Add midpoints
                new THREE.Vector3((box.min.x + box.max.x) / 2, (box.min.y + box.max.y) / 2, box.min.z),
                new THREE.Vector3((box.min.x + box.max.x) / 2, (box.min.y + box.max.y) / 2, box.max.z)
            ];
        }
        
        // Update snap line
        function updateSnapLine() {
            if (!app.activePiece || !app.movementAxis) {
                if (app.snapLine) {
                    app.scene.remove(app.snapLine);
                    app.snapLine = null;
                }
                return;
            }
            
            // Remove existing line
            if (app.snapLine) {
                app.scene.remove(app.snapLine);
            }
            
            // Create stippled line along movement axis
            const geometry = new THREE.BufferGeometry();
            const points = [];
            const start = app.activePiece.position.clone();
            const end = start.clone();
            
            if (app.movementAxis === 'x') {
                start.x -= 5;
                end.x += 5;
            } else if (app.movementAxis === 'y') {
                start.y -= 5;
                end.y += 5;
            } else if (app.movementAxis === 'z') {
                start.z -= 5;
                end.z += 5;
            }
            
            points.push(start, end);
            geometry.setFromPoints(points);
            
            const material = new THREE.LineDashedMaterial({
                color: 0x0088ff,
                dashSize: 0.05,
                gapSize: 0.05
            });
            
            app.snapLine = new THREE.Line(geometry, material);
            app.snapLine.computeLineDistances();
            app.scene.add(app.snapLine);
        }
        
        // Adjust piece length
        function adjustLength(event) {
            if (!app.activePiece || !app.isLengthEditing) return;
            
            const delta = (event.clientX - app.lastMouseX) * 10; // 10mm per pixel
            const newLength = Math.max(0, app.activePiece.userData.length + delta);
            
            // Update geometry
            const t = app.activePiece.userData.thickness / 1000;
            const w = app.activePiece.userData.width / 1000;
            const l = newLength / 1000;
            
            app.activePiece.geometry.dispose();
            app.activePiece.geometry = new THREE.BoxGeometry(t, w, l);
            app.activePiece.userData.length = newLength;
            
            // Show red if will be deleted
            if (newLength < 10) {
                app.activePiece.material.color.setHex(0xff0000);
            } else {
                app.activePiece.material.color.setHex(0x8B6F47);
            }
            
            // Show measurement
            showMeasurement(`Length: ${Math.round(newLength)}mm`);
        }
        
        // Rotate piece
        function rotatePiece(piece, axis) {
            const rotation = Math.PI / 2;
            
            if (axis === 'x') {
                piece.rotateX(rotation);
            } else if (axis === 'y') {
                piece.rotateY(rotation);
            } else if (axis === 'z') {
                piece.rotateZ(rotation);
            }
            
            checkCollisionAndSnap();
        }
        
        // Place active piece
        function placeActivePiece() {
            if (!app.activePiece) return;
            
            // Check if valid position (not red)
            if (app.activePiece.material.color.getHex() === 0xff0000) {
                // Cancel placement
                app.scene.remove(app.activePiece);
                app.activePiece = null;
                updateHotkeyGuide();
                return;
            }
            
            // Mark as placed
            app.activePiece.userData.isActive = false;
            
            // Save state for undo
            saveState();
            
            // Clear active piece
            app.activePiece = null;
            
            // Save project
            saveCurrentProject();
            
            updateHotkeyGuide();
        }
        
        // Duplicate piece
        function duplicatePiece(original) {
            const clone = original.clone();
            clone.userData = { ...original.userData };
            clone.userData.isActive = true;
            
            // Offset slightly
            clone.position.add(new THREE.Vector3(0.1, 0.1, 0.1));
            
            app.scene.add(clone);
            app.activePiece = clone;
            
            updateHotkeyGuide();
        }
        
        // Delete selected pieces
        function deleteSelectedPieces() {
            saveState();
            
            app.selectedPieces.forEach(piece => {
                app.scene.remove(piece);
            });
            
            app.selectedPieces.clear();
            saveCurrentProject();
            updateHotkeyGuide();
        }
        
        // Clear selection
        function clearSelection() {
            app.selectedPieces.forEach(piece => {
                updatePieceSelection(piece, false);
            });
            app.selectedPieces.clear();
        }
        
        // Update piece selection visual
        function updatePieceSelection(piece, selected) {
            if (selected) {
                piece.material = piece.material.clone();
                piece.material.emissive = new THREE.Color(0xff0000);
                piece.material.emissiveIntensity = 0.2;
            } else {
                piece.material.emissive = new THREE.Color(0x000000);
                piece.material.emissiveIntensity = 0;
            }
        }
        
        // Show measurement
        function showMeasurement(text) {
            const measurement = document.getElementById('measurement');
            measurement.textContent = typeof text === 'number' ? `${Math.round(text)}mm` : text;
            measurement.classList.remove('hidden');
            
            clearTimeout(app.measurementTimeout);
            app.measurementTimeout = setTimeout(() => {
                measurement.classList.add('hidden');
            }, 2000);
        }
        
        // Update hotkey guide
        function updateHotkeyGuide() {
            const activeGuide = document.getElementById('activeGuide');
            const selectedGuide = document.getElementById('selectedGuide');
            
            if (app.activePiece) {
                activeGuide.style.display = 'block';
                selectedGuide.style.display = 'none';
            } else if (app.selectedPieces.size > 0) {
                activeGuide.style.display = 'none';
                selectedGuide.style.display = 'block';
            } else {
                activeGuide.style.display = 'none';
                selectedGuide.style.display = 'none';
            }
        }
        
        // Project management
        function loadProjects() {
            const saved = localStorage.getItem('woodProjects');
            if (saved) {
                app.projects = JSON.parse(saved);
            } else {
                app.projects = {
                    'Project 1': { pieces: [] }
                };
            }
            
            // Load first project
            const projectNames = Object.keys(app.projects);
            if (projectNames.length > 0) {
                loadProject(projectNames[0]);
            }
            
            updateProjectList();
        }
        
        function saveCurrentProject() {
            if (!app.currentProject) return;
            
            const pieces = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece && !obj.userData.isActive) {
                    pieces.push({
                        thickness: obj.userData.thickness,
                        width: obj.userData.width,
                        length: obj.userData.length,
                        position: obj.position.toArray(),
                        rotation: obj.rotation.toArray()
                    });
                }
            });
            
            app.projects[app.currentProject] = { pieces };
            localStorage.setItem('woodProjects', JSON.stringify(app.projects));
        }
        
        function loadProject(name) {
            // Clear scene
            const toRemove = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece) {
                    toRemove.push(obj);
                }
            });
            toRemove.forEach(obj => app.scene.remove(obj));
            
            // Load pieces
            const project = app.projects[name];
            if (project && project.pieces) {
                project.pieces.forEach(data => {
                    const t = data.thickness / 1000;
                    const w = data.width / 1000;
                    const l = data.length / 1000;
                    
                    const geometry = new THREE.BoxGeometry(t, w, l);
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x8B6F47,
                        roughness: 0.7,
                        metalness: 0.1
                    });
                    
                    const piece = new THREE.Mesh(geometry, material);
                    piece.castShadow = true;
                    piece.receiveShadow = true;
                    
                    piece.userData = {
                        thickness: data.thickness,
                        width: data.width,
                        length: data.length,
                        isWoodPiece: true,
                        isActive: false
                    };
                    
                    piece.position.fromArray(data.position);
                    piece.rotation.fromArray(data.rotation);
                    
                    app.scene.add(piece);
                });
            }
            
            app.currentProject = name;
            updateProjectList();
        }
        
        function updateProjectList() {
            const projectList = document.getElementById('projectList');
            projectList.innerHTML = '';
            
            Object.keys(app.projects).forEach(name => {
                const item = document.createElement('div');
                item.className = 'project-item';
                if (name === app.currentProject) {
                    item.classList.add('active');
                }
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = name;
                nameSpan.style.cursor = 'pointer';
                nameSpan.onclick = () => loadProject(name);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteProject(name);
                };
                
                item.appendChild(nameSpan);
                item.appendChild(deleteBtn);
                projectList.appendChild(item);
            });
        }
        
        function createNewProject() {
            const name = prompt('Project name:', `Project ${Object.keys(app.projects).length + 1}`);
            if (name && !app.projects[name]) {
                app.projects[name] = { pieces: [] };
                saveCurrentProject();
                loadProject(name);
            }
        }
        
        function renameProject() {
            if (!app.currentProject) return;
            
            const newName = prompt('New name:', app.currentProject);
            if (newName && newName !== app.currentProject && !app.projects[newName]) {
                app.projects[newName] = app.projects[app.currentProject];
                delete app.projects[app.currentProject];
                app.currentProject = newName;
                localStorage.setItem('woodProjects', JSON.stringify(app.projects));
                updateProjectList();
            }
        }
        
        function deleteProject(name) {
            if (Object.keys(app.projects).length <= 1) {
                alert('Cannot delete the last project');
                return;
            }
            
            if (confirm(`Delete project "${name}"?`)) {
                delete app.projects[name];
                
                if (name === app.currentProject) {
                    const remaining = Object.keys(app.projects);
                    if (remaining.length > 0) {
                        loadProject(remaining[0]);
                    }
                }
                
                localStorage.setItem('woodProjects', JSON.stringify(app.projects));
                updateProjectList();
            }
        }
        
        // Undo/Redo functionality
        function saveState() {
            const state = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece && !obj.userData.isActive) {
                    state.push({
                        thickness: obj.userData.thickness,
                        width: obj.userData.width,
                        length: obj.userData.length,
                        position: obj.position.toArray(),
                        rotation: obj.rotation.toArray()
                    });
                }
            });
            
            app.undoStack.push(state);
            app.redoStack = [];
            
            // Limit stack size
            if (app.undoStack.length > 50) {
                app.undoStack.shift();
            }
        }
        
        function undo() {
            if (app.undoStack.length === 0) return;
            
            const currentState = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece && !obj.userData.isActive) {
                    currentState.push({
                        thickness: obj.userData.thickness,
                        width: obj.userData.width,
                        length: obj.userData.length,
                        position: obj.position.toArray(),
                        rotation: obj.rotation.toArray()
                    });
                }
            });
            
            app.redoStack.push(currentState);
            
            const previousState = app.undoStack.pop();
            restoreState(previousState);
        }
        
        function redo() {
            if (app.redoStack.length === 0) return;
            
            const nextState = app.redoStack.pop();
            saveState();
            restoreState(nextState);
        }
        
        function restoreState(state) {
            // Clear current pieces
            const toRemove = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece && !obj.userData.isActive) {
                    toRemove.push(obj);
                }
            });
            toRemove.forEach(obj => app.scene.remove(obj));
            
            // Restore pieces
            state.forEach(data => {
                const t = data.thickness / 1000;
                const w = data.width / 1000;
                const l = data.length / 1000;
                
                const geometry = new THREE.BoxGeometry(t, w, l);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x8B6F47,
                    roughness: 0.7,
                    metalness: 0.1
                });
                
                const piece = new THREE.Mesh(geometry, material);
                piece.castShadow = true;
                piece.receiveShadow = true;
                
                piece.userData = {
                    thickness: data.thickness,
                    width: data.width,
                    length: data.length,
                    isWoodPiece: true,
                    isActive: false
                };
                
                piece.position.fromArray(data.position);
                piece.rotation.fromArray(data.rotation);
                
                app.scene.add(piece);
            });
            
            saveCurrentProject();
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            app.renderer.render(app.scene, app.camera);
        }
        
        // Initialize on load
        window.addEventListener('load', init);
        
        // Expose app functions to window for UI
        window.app = app;
    </script>
</body>
</html>

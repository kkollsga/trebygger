<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Wood Construction</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            user-select: none;
            background: #1a1a1a;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        #canvas.grabbing {
            cursor: grabbing;
        }
        
        /* Hamburger Menu Button */
        .menu-button {
            position: fixed;
            left: 20px;
            top: 20px;
            width: 40px;
            height: 40px;
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            z-index: 1001;
            transition: all 0.2s;
        }
        
        .menu-button:hover {
            background: rgba(60, 60, 60, 0.9);
        }
        
        .menu-button span {
            width: 24px;
            height: 2px;
            background: #fff;
            transition: all 0.3s;
        }
        
        .menu-button.active span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }
        
        .menu-button.active span:nth-child(2) {
            opacity: 0;
        }
        
        .menu-button.active span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }
        
        /* Side Panel */
        .side-panel {
            position: fixed;
            left: -350px;
            top: 0;
            background: rgba(40, 40, 40, 0.95);
            height: 100vh;
            width: 330px;
            padding: 80px 20px 20px;
            box-shadow: 2px 0 20px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
            transition: left 0.3s ease;
            z-index: 1000;
        }
        
        .side-panel.active {
            left: 0;
        }
        
        .panel-section {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel-section:last-child {
            border-bottom: none;
        }
        
        .panel-section h3 {
            font-size: 14px;
            margin-bottom: 15px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Material Selection */
        .thickness-group {
            margin-bottom: 20px;
        }
        
        .thickness-group h4 {
            font-size: 12px;
            color: #999;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .wood-option {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 6px 0;
            background: rgba(60, 60, 60, 0.6);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        
        .wood-option:hover {
            background: rgba(80, 80, 80, 0.6);
            transform: translateX(4px);
        }
        
        .wood-option.active {
            background: rgba(33, 150, 243, 0.2);
            border-color: #2196f3;
        }
        
        .wood-icon {
            width: 40px;
            height: 40px;
            margin-right: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            background: #2a2a2a;
        }
        
        .wood-label {
            font-size: 13px;
            font-weight: 500;
            color: #fff;
        }
        
        /* Project Management */
        .project-list {
            margin-bottom: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .project-item {
            padding: 8px 10px;
            margin: 4px 0;
            background: rgba(60, 60, 60, 0.6);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #fff;
            transition: all 0.2s;
        }
        
        .project-item:hover {
            background: rgba(80, 80, 80, 0.6);
        }
        
        .project-item.active {
            background: rgba(33, 150, 243, 0.2);
            font-weight: 500;
            border: 1px solid #2196f3;
        }
        
        .project-item button {
            padding: 2px 6px;
            font-size: 10px;
            background: #d32f2f;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .project-item button:hover {
            background: #b71c1c;
        }
        
        .project-controls button {
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .project-controls button:hover {
            background: #1976d2;
        }
        
        /* Overlay for closing menu */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 999;
            display: none;
        }
        
        .menu-overlay.active {
            display: block;
        }
        
        /* Hotkey Guide */
        .hotkey-guide {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 11px;
            transition: opacity 0.3s;
            max-width: 300px;
        }
        
        .hotkey-guide.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .hotkey-group {
            margin-bottom: 10px;
        }
        
        .hotkey-group h4 {
            font-size: 12px;
            margin-bottom: 5px;
            color: #4fc3f7;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .hotkey {
            display: flex;
            margin: 3px 0;
            color: #ccc;
        }
        
        .hotkey-key {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 8px;
            font-family: monospace;
            min-width: 20px;
            text-align: center;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Measurement Display */
        .measurement {
            position: fixed;
            background: rgba(33, 150, 243, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .measurement.hidden {
            opacity: 0;
        }
        
        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #999;
        }
        
        /* Status indicator */
        .status-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(33, 150, 243, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 100;
        }
        
        .status-indicator.hidden {
            opacity: 0;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading 3D environment...</div>
    <canvas id="canvas"></canvas>
    
    <!-- Hamburger Menu Button -->
    <div class="menu-button" id="menuButton" onclick="toggleMenu()">
        <span></span>
        <span></span>
        <span></span>
    </div>
    
    <!-- Menu Overlay -->
    <div class="menu-overlay" id="menuOverlay" onclick="closeMenu()"></div>
    
    <!-- Side Panel -->
    <div class="side-panel" id="sidePanel">
        <!-- Projects Section -->
        <div class="panel-section">
            <h3>Projects</h3>
            <div class="project-list" id="projectList"></div>
            <div class="project-controls">
                <button onclick="app.createNewProject()">New Project</button>
                <button onclick="app.renameProject()">Rename</button>
            </div>
        </div>
        
        <!-- Materials Section -->
        <div class="panel-section">
            <h3>Wood Materials</h3>
            <div id="materialList"></div>
        </div>
    </div>
    
    <!-- Hotkey Guide -->
    <div class="hotkey-guide" id="hotkeyGuide">
        <div class="hotkey-group" id="movementGuide" style="display: none;">
            <h4>Movement Mode Active</h4>
            <div class="hotkey"><span class="hotkey-key">Click + Drag</span> Move along axis</div>
            <div class="hotkey"><span class="hotkey-key">Release Key</span> Exit mode</div>
        </div>
        <div class="hotkey-group" id="selectedGuide" style="display: none;">
            <h4>Selected Pieces</h4>
            <div class="hotkey"><span class="hotkey-key">Z</span> Hold + drag for Z movement</div>
            <div class="hotkey"><span class="hotkey-key">X</span> Hold + drag for X movement</div>
            <div class="hotkey"><span class="hotkey-key">C</span> Hold + drag for Y movement</div>
            <div class="hotkey"><span class="hotkey-key">A</span> Rotate around Z</div>
            <div class="hotkey"><span class="hotkey-key">S</span> Rotate around X</div>
            <div class="hotkey"><span class="hotkey-key">D</span> Rotate around Y</div>
            <div class="hotkey"><span class="hotkey-key">E</span> + Click to duplicate</div>
            <div class="hotkey"><span class="hotkey-key">T</span> Delete selected</div>
            <div class="hotkey"><span class="hotkey-key">V</span> + Click end to adjust length</div>
        </div>
        <div class="hotkey-group" id="generalGuide">
            <h4>General</h4>
            <div class="hotkey"><span class="hotkey-key">Click</span> Select piece</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl + Click</span> Multi-select</div>
            <div class="hotkey"><span class="hotkey-key">Left Drag</span> Pan camera</div>
            <div class="hotkey"><span class="hotkey-key">Right Drag</span> Orbit camera</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl+Z</span> Undo</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl+Y</span> Redo</div>
            <div class="hotkey"><span class="hotkey-key">1-0</span> Quick material select</div>
        </div>
    </div>
    
    <!-- Measurement Display -->
    <div class="measurement hidden" id="measurement"></div>
    
    <!-- Status Indicator -->
    <div class="status-indicator hidden" id="statusIndicator"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global app object
        const app = {
            scene: null,
            camera: null,
            renderer: null,
            raycaster: new THREE.Raycaster(),
            mouse: new THREE.Vector2(),
            
            // State
            selectedPieces: new Set(),
            movementAxis: null,
            isDraggingPiece: false,
            dragStartPos: null,
            isLengthEditing: false,
            lengthEditPiece: null,
            lengthEditFace: null,
            
            // Input state
            keys: {},
            mouseDown: false,
            rightMouseDown: false,
            lastMouseX: 0,
            lastMouseY: 0,
            
            // Camera state
            cameraDistance: 3,
            cameraTheta: Math.PI / 4,
            cameraPhi: Math.PI / 3,
            cameraTarget: new THREE.Vector3(0, 0, 0),
            
            // Wood dimensions (thickness x width in mm)
            woodDimensions: [
                { thickness: 20, widths: [48, 73, 98, 120] },
                { thickness: 28, widths: [48, 73, 98, 120] },
                { thickness: 36, widths: [48, 73, 98, 120] },
                { thickness: 48, widths: [48, 73, 98, 120] },
                { thickness: 98, widths: [48, 73, 98, 120] }
            ],
            
            selectedDimension: null,
            recentDimensions: [],
            
            // Project management
            projects: {},
            currentProject: null,
            
            // Undo/Redo
            undoStack: [],
            redoStack: [],
            
            // Visual helpers
            snapLines: [],
            measurementTimeout: null,
            measurementElement: null,
            statusTimeout: null
        };
        
        // Menu toggle functions
        function toggleMenu() {
            const panel = document.getElementById('sidePanel');
            const button = document.getElementById('menuButton');
            const overlay = document.getElementById('menuOverlay');
            
            panel.classList.toggle('active');
            button.classList.toggle('active');
            overlay.classList.toggle('active');
        }
        
        function closeMenu() {
            const panel = document.getElementById('sidePanel');
            const button = document.getElementById('menuButton');
            const overlay = document.getElementById('menuOverlay');
            
            panel.classList.remove('active');
            button.classList.remove('active');
            overlay.classList.remove('active');
        }
        
        // Show status message
        function showStatus(message) {
            const status = document.getElementById('statusIndicator');
            status.textContent = message;
            status.classList.remove('hidden');
            
            clearTimeout(app.statusTimeout);
            app.statusTimeout = setTimeout(() => {
                status.classList.add('hidden');
            }, 2000);
        }
        
        // Initialize the application
        function init() {
            // Setup Three.js
            app.scene = new THREE.Scene();
            app.scene.background = new THREE.Color(0x1a1a1a);
            app.scene.fog = new THREE.Fog(0x1a1a1a, 10, 50);
            
            // Camera setup (Z is up)
            app.camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            updateCameraPosition();
            
            // Renderer
            const canvas = document.getElementById('canvas');
            app.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            app.renderer.setSize(window.innerWidth, window.innerHeight);
            app.renderer.shadowMap.enabled = true;
            app.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            app.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, -5, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            app.scene.add(directionalLight);
            
            // Ground plane (solid gray)
            const groundGeometry = new THREE.BoxGeometry(40, 40, 0.1);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a4a4a,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.position.z = -0.05;
            ground.receiveShadow = true;
            ground.userData.isGround = true;
            app.scene.add(ground);
            
            // Add subtle grid on top of ground
            const gridHelper = new THREE.GridHelper(40, 80, 0x555555, 0x3a3a3a);
            gridHelper.rotation.x = Math.PI / 2;
            gridHelper.position.z = 0.001;
            app.scene.add(gridHelper);
            
            // Initialize UI
            initializeMaterialPanel();
            loadProjects();
            
            // Create measurement element
            app.measurementElement = document.getElementById('measurement');
            
            // Event listeners
            setupEventListeners();
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Start render loop
            animate();
        }
        
        // Update camera position based on spherical coordinates
        function updateCameraPosition() {
            app.camera.position.x = app.cameraTarget.x + app.cameraDistance * Math.sin(app.cameraTheta) * Math.sin(app.cameraPhi);
            app.camera.position.y = app.cameraTarget.y + app.cameraDistance * Math.cos(app.cameraTheta) * Math.sin(app.cameraPhi);
            app.camera.position.z = app.cameraTarget.z + app.cameraDistance * Math.cos(app.cameraPhi);
            app.camera.lookAt(app.cameraTarget);
        }
        
        // Initialize material selection panel
        function initializeMaterialPanel() {
            const materialList = document.getElementById('materialList');
            
            app.woodDimensions.forEach((group, groupIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'thickness-group';
                
                const groupTitle = document.createElement('h4');
                groupTitle.textContent = `${group.thickness}mm Thickness`;
                groupDiv.appendChild(groupTitle);
                
                group.widths.forEach((width, widthIndex) => {
                    const option = document.createElement('div');
                    option.className = 'wood-option';
                    option.dataset.thickness = group.thickness;
                    option.dataset.width = width;
                    
                    // Create visual icon (1:10 scale)
                    const icon = document.createElement('canvas');
                    icon.className = 'wood-icon';
                    icon.width = 40;
                    icon.height = 40;
                    const ctx = icon.getContext('2d');
                    
                    // Draw cross-section at 1:10 scale
                    const scale = 0.3;
                    const t = group.thickness * scale;
                    const w = width * scale;
                    
                    ctx.fillStyle = '#8B6F47';
                    ctx.fillRect(
                        (40 - t) / 2,
                        (40 - w) / 2,
                        t,
                        w
                    );
                    
                    ctx.strokeStyle = '#6B5637';
                    ctx.strokeRect(
                        (40 - t) / 2,
                        (40 - w) / 2,
                        t,
                        w
                    );
                    
                    const label = document.createElement('div');
                    label.className = 'wood-label';
                    label.textContent = `${group.thickness}×${width}mm`;
                    
                    option.appendChild(icon);
                    option.appendChild(label);
                    
                    option.addEventListener('click', () => {
                        selectWoodDimension(group.thickness, width);
                        closeMenu();
                    });
                    
                    groupDiv.appendChild(option);
                });
                
                materialList.appendChild(groupDiv);
            });
        }
        
        // Select wood dimension
        function selectWoodDimension(thickness, width) {
            // Update UI
            document.querySelectorAll('.wood-option').forEach(opt => {
                opt.classList.remove('active');
            });
            
            const selected = document.querySelector(
                `.wood-option[data-thickness="${thickness}"][data-width="${width}"]`
            );
            if (selected) {
                selected.classList.add('active');
            }
            
            app.selectedDimension = { thickness, width };
            
            // Update recent dimensions
            const key = `${thickness}x${width}`;
            app.recentDimensions = app.recentDimensions.filter(d => d !== key);
            app.recentDimensions.unshift(key);
            if (app.recentDimensions.length > 10) {
                app.recentDimensions.pop();
            }
            
            // Create new wood piece
            createWoodPiece(thickness, width);
        }
        
        // Create wood piece
        function createWoodPiece(thickness, width, length = 500) {
            // Convert mm to scene units (1 unit = 1 meter)
            const t = thickness / 1000;
            const w = width / 1000;
            const l = length / 1000;
            
            // Create geometry
            const geometry = new THREE.BoxGeometry(t, w, l);
            const material = new THREE.MeshStandardMaterial({
                color: 0x8B6F47,
                roughness: 0.7,
                metalness: 0.1
            });
            
            const piece = new THREE.Mesh(geometry, material);
            piece.castShadow = true;
            piece.receiveShadow = true;
            
            // Store dimensions in userData
            piece.userData = {
                thickness,
                width,
                length,
                isWoodPiece: true
            };
            
            // Position on the floor at camera target
            piece.position.set(
                app.cameraTarget.x,
                app.cameraTarget.y,
                l / 2
            );
            
            // Add to scene
            app.scene.add(piece);
            
            // Select the new piece
            clearSelection();
            app.selectedPieces.add(piece);
            updatePieceSelection(piece, true);
            
            // Save state
            saveState();
            saveCurrentProject();
            
            updateHotkeyGuide();
            showStatus(`Created ${thickness}×${width}mm piece`);
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', onWindowResize);
            
            // Mouse events
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('contextmenu', e => e.preventDefault());
            
            // Keyboard events
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Mouse wheel
            document.addEventListener('wheel', onMouseWheel);
        }
        
        // Window resize handler
        function onWindowResize() {
            app.camera.aspect = window.innerWidth / window.innerHeight;
            app.camera.updateProjectionMatrix();
            app.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Mouse down handler
        function onMouseDown(event) {
            if (event.target.id !== 'canvas') return;
            
            if (event.button === 0) {
                app.mouseDown = true;
                updateMouse(event);
                
                // Check what we're clicking on
                app.raycaster.setFromCamera(app.mouse, app.camera);
                const objects = app.scene.children.filter(obj => obj.userData.isWoodPiece);
                const intersects = app.raycaster.intersectObjects(objects);
                
                if (intersects.length > 0) {
                    const clickedPiece = intersects[0].object;
                    
                    // Check for special modes
                    if (app.keys['v'] && app.selectedPieces.has(clickedPiece)) {
                        // Length editing mode
                        const face = intersects[0].face;
                        const normal = face.normal.clone();
                        normal.transformDirection(clickedPiece.matrixWorld);
                        
                        if (Math.abs(normal.z) > 0.9) {
                            app.isLengthEditing = true;
                            app.lengthEditPiece = clickedPiece;
                            app.lengthEditFace = normal.z > 0 ? 'top' : 'bottom';
                        }
                    } else if (app.keys['e']) {
                        // Duplicate mode
                        duplicatePiece(clickedPiece);
                    } else if (app.movementAxis && app.selectedPieces.has(clickedPiece)) {
                        // Start dragging in 1D movement mode
                        app.isDraggingPiece = true;
                        app.dragStartPos = intersects[0].point.clone();
                    } else {
                        // Selection
                        if (event.ctrlKey) {
                            // Toggle selection
                            if (app.selectedPieces.has(clickedPiece)) {
                                app.selectedPieces.delete(clickedPiece);
                                updatePieceSelection(clickedPiece, false);
                            } else {
                                app.selectedPieces.add(clickedPiece);
                                updatePieceSelection(clickedPiece, true);
                            }
                        } else {
                            // Single selection
                            if (!app.selectedPieces.has(clickedPiece)) {
                                clearSelection();
                                app.selectedPieces.add(clickedPiece);
                                updatePieceSelection(clickedPiece, true);
                            }
                        }
                        updateHotkeyGuide();
                    }
                } else if (!event.ctrlKey && !app.movementAxis) {
                    // Clicked on empty space - clear selection
                    clearSelection();
                    updateHotkeyGuide();
                }
                
            } else if (event.button === 2) {
                app.rightMouseDown = true;
            }
            
            app.lastMouseX = event.clientX;
            app.lastMouseY = event.clientY;
            
            document.getElementById('canvas').classList.add('grabbing');
        }
        
        // Mouse move handler
        function onMouseMove(event) {
            const deltaX = event.clientX - app.lastMouseX;
            const deltaY = event.clientY - app.lastMouseY;
            
            if (app.isDraggingPiece && app.movementAxis) {
                // Move selected pieces along axis
                moveSelectedAlongAxis(event);
            } else if (app.isLengthEditing) {
                // Adjust length
                adjustLength(event);
            } else if (app.mouseDown && !app.movementAxis) {
                // Camera panning
                const panSpeed = 0.003;
                const right = new THREE.Vector3();
                const forward = new THREE.Vector3();
                
                app.camera.getWorldDirection(forward);
                forward.z = 0;
                forward.normalize();
                right.crossVectors(forward, new THREE.Vector3(0, 0, 1)).normalize();
                
                app.cameraTarget.add(right.multiplyScalar(-deltaX * panSpeed));
                app.cameraTarget.add(forward.multiplyScalar(deltaY * panSpeed));
                updateCameraPosition();
                
            } else if (app.rightMouseDown) {
                // Camera orbiting (no head tilting)
                const orbitSpeed = 0.005;
                app.cameraTheta -= deltaX * orbitSpeed;
                app.cameraPhi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, app.cameraPhi));
                
                updateCameraPosition();
            }
            
            app.lastMouseX = event.clientX;
            app.lastMouseY = event.clientY;
            
            updateMouse(event);
        }
        
        // Mouse up handler
        function onMouseUp(event) {
            if (event.button === 0) {
                app.mouseDown = false;
                
                if (app.isDraggingPiece || app.isLengthEditing) {
                    // Save state after movement/editing
                    saveState();
                    saveCurrentProject();
                }
                
                app.isDraggingPiece = false;
                app.dragStartPos = null;
                app.isLengthEditing = false;
                app.lengthEditPiece = null;
                app.lengthEditFace = null;
                
            } else if (event.button === 2) {
                app.rightMouseDown = false;
            }
            
            document.getElementById('canvas').classList.remove('grabbing');
            
            // Clear snap lines
            clearSnapLines();
            
            // Hide measurement
            hideMeasurement();
        }
        
        // Key down handler
        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            app.keys[key] = true;
            
            // Movement axis controls - enable axis mode while key is held
            if (app.selectedPieces.size > 0 && !event.repeat) {
                if (key === 'z') {
                    app.movementAxis = 'z';
                    updateSnapLines();
                    showStatus('Z-axis movement mode');
                    updateHotkeyGuide();
                } else if (key === 'x') {
                    app.movementAxis = 'x';
                    updateSnapLines();
                    showStatus('X-axis movement mode');
                    updateHotkeyGuide();
                } else if (key === 'c') {
                    app.movementAxis = 'y';
                    updateSnapLines();
                    showStatus('Y-axis movement mode');
                    updateHotkeyGuide();
                }
                
                // Rotation controls
                if (key === 'a') {
                    rotateSelected('z');
                } else if (key === 's') {
                    rotateSelected('x');
                } else if (key === 'd') {
                    rotateSelected('y');
                }
            }
            
            // Delete selected
            if (key === 't' && app.selectedPieces.size > 0) {
                deleteSelectedPieces();
            }
            
            // Undo/Redo
            if (event.ctrlKey) {
                if (key === 'z') {
                    event.preventDefault();
                    undo();
                } else if (key === 'y') {
                    event.preventDefault();
                    redo();
                }
            }
            
            // Quick material selection (1-0 keys)
            const numKey = parseInt(event.key);
            if (!isNaN(numKey) && numKey >= 0 && numKey <= 9) {
                const index = numKey === 0 ? 9 : numKey - 1;
                if (app.recentDimensions[index]) {
                    const [thickness, width] = app.recentDimensions[index].split('x').map(Number);
                    selectWoodDimension(thickness, width);
                }
            }
        }
        
        // Key up handler
        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            delete app.keys[key];
            
            // Clear movement axis when key released
            if ((key === 'z' && app.movementAxis === 'z') ||
                (key === 'x' && app.movementAxis === 'x') ||
                (key === 'c' && app.movementAxis === 'y')) {
                app.movementAxis = null;
                app.isDraggingPiece = false;
                clearSnapLines();
                hideMeasurement();
                updateHotkeyGuide();
            }
        }
        
        // Mouse wheel handler
        function onMouseWheel(event) {
            const zoomSpeed = 0.001;
            app.cameraDistance += event.deltaY * zoomSpeed;
            app.cameraDistance = Math.max(0.5, Math.min(20, app.cameraDistance));
            updateCameraPosition();
        }
        
        // Update mouse position
        function updateMouse(event) {
            app.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            app.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        
        // Move selected pieces along axis
        function moveSelectedAlongAxis(event) {
            if (!app.movementAxis || app.selectedPieces.size === 0) return;
            
            // Get current intersection point
            app.raycaster.setFromCamera(app.mouse, app.camera);
            
            // Create a plane perpendicular to view for dragging
            const planeNormal = new THREE.Vector3();
            app.camera.getWorldDirection(planeNormal);
            const plane = new THREE.Plane(planeNormal, -app.dragStartPos.dot(planeNormal));
            
            const intersectPoint = new THREE.Vector3();
            app.raycaster.ray.intersectPlane(plane, intersectPoint);
            
            if (intersectPoint) {
                // Calculate movement delta along the constrained axis
                const delta = intersectPoint.sub(app.dragStartPos);
                const movement = new THREE.Vector3();
                movement[app.movementAxis] = delta[app.movementAxis];
                
                // Check for snapping
                const snapInfo = checkSnapForMovement(movement);
                if (snapInfo.snapDelta) {
                    movement.add(snapInfo.snapDelta);
                }
                
                // Move all selected pieces
                let hasCollision = false;
                app.selectedPieces.forEach(piece => {
                    const newPos = piece.position.clone().add(movement);
                    
                    // Check collision for vertical movement
                    if (app.movementAxis === 'z') {
                        const testBox = new THREE.Box3().setFromObject(piece);
                        testBox.translate(movement);
                        
                        let collision = false;
                        app.scene.traverse((obj) => {
                            if (obj.userData.isWoodPiece && !app.selectedPieces.has(obj)) {
                                const targetBox = new THREE.Box3().setFromObject(obj);
                                if (testBox.intersectsBox(targetBox)) {
                                    collision = true;
                                }
                            }
                        });
                        
                        if (collision) {
                            hasCollision = true;
                            piece.material.color.setHex(0xff0000);
                        } else {
                            piece.material.color.setHex(0x8B6F47);
                        }
                    }
                    
                    piece.position.copy(newPos);
                });
                
                // Update drag start for next frame
                app.dragStartPos.add(movement);
                
                // Show measurement
                if (snapInfo.distance !== null) {
                    showMeasurement(Math.abs(snapInfo.distance) * 1000);
                    updateMeasurementPosition(snapInfo.measurementPos);
                }
            }
        }
        
        // Check for snapping during movement
        function checkSnapForMovement(movement) {
            const snapThreshold = 0.01; // 10mm
            let minDistance = Infinity;
            let snapDelta = null;
            let measurementPos = null;
            
            // Get bounding box of all selected pieces
            const selectionBox = new THREE.Box3();
            app.selectedPieces.forEach(piece => {
                const box = new THREE.Box3().setFromObject(piece);
                box.translate(movement);
                selectionBox.union(box);
            });
            
            // Check against non-selected pieces
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece && !app.selectedPieces.has(obj)) {
                    const targetBox = new THREE.Box3().setFromObject(obj);
                    const corners = getBoxCorners(targetBox);
                    
                    corners.forEach(corner => {
                        // Check distance along movement axis
                        const selectionCorners = getBoxCorners(selectionBox);
                        selectionCorners.forEach(selCorner => {
                            const distance = corner[app.movementAxis] - selCorner[app.movementAxis];
                            
                            if (Math.abs(distance) < snapThreshold && Math.abs(distance) < Math.abs(minDistance)) {
                                minDistance = distance;
                                snapDelta = new THREE.Vector3();
                                snapDelta[app.movementAxis] = distance;
                                
                                // Calculate measurement position
                                measurementPos = selCorner.clone();
                                measurementPos[app.movementAxis] = (selCorner[app.movementAxis] + corner[app.movementAxis]) / 2;
                            }
                        });
                    });
                }
            });
            
            return {
                snapDelta,
                distance: minDistance,
                measurementPos
            };
        }
        
        // Rotate selected pieces
        function rotateSelected(axis) {
            if (app.selectedPieces.size === 0) return;
            
            // Calculate center of selection
            const center = new THREE.Vector3();
            app.selectedPieces.forEach(piece => {
                center.add(piece.position);
            });
            center.divideScalar(app.selectedPieces.size);
            
            // Rotate each piece
            const rotation = Math.PI / 2;
            app.selectedPieces.forEach(piece => {
                // Rotate around own center
                if (axis === 'x') {
                    piece.rotateX(rotation);
                } else if (axis === 'y') {
                    piece.rotateY(rotation);
                } else if (axis === 'z') {
                    piece.rotateZ(rotation);
                }
                
                // If multiple pieces, also rotate position around group center
                if (app.selectedPieces.size > 1) {
                    const offset = piece.position.clone().sub(center);
                    if (axis === 'x') {
                        offset.applyAxisAngle(new THREE.Vector3(1, 0, 0), rotation);
                    } else if (axis === 'y') {
                        offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation);
                    } else if (axis === 'z') {
                        offset.applyAxisAngle(new THREE.Vector3(0, 0, 1), rotation);
                    }
                    piece.position.copy(center.clone().add(offset));
                }
            });
            
            saveState();
            saveCurrentProject();
            showStatus(`Rotated around ${axis.toUpperCase()} axis`);
        }
        
        // Get box corners
        function getBoxCorners(box) {
            return [
                new THREE.Vector3(box.min.x, box.min.y, box.min.z),
                new THREE.Vector3(box.max.x, box.min.y, box.min.z),
                new THREE.Vector3(box.min.x, box.max.y, box.min.z),
                new THREE.Vector3(box.max.x, box.max.y, box.min.z),
                new THREE.Vector3(box.min.x, box.min.y, box.max.z),
                new THREE.Vector3(box.max.x, box.min.y, box.max.z),
                new THREE.Vector3(box.min.x, box.max.y, box.max.z),
                new THREE.Vector3(box.max.x, box.max.y, box.max.z),
                // Add midpoints
                new THREE.Vector3((box.min.x + box.max.x) / 2, (box.min.y + box.max.y) / 2, box.min.z),
                new THREE.Vector3((box.min.x + box.max.x) / 2, (box.min.y + box.max.y) / 2, box.max.z),
                new THREE.Vector3(box.min.x, (box.min.y + box.max.y) / 2, (box.min.z + box.max.z) / 2),
                new THREE.Vector3(box.max.x, (box.min.y + box.max.y) / 2, (box.min.z + box.max.z) / 2),
                new THREE.Vector3((box.min.x + box.max.x) / 2, box.min.y, (box.min.z + box.max.z) / 2),
                new THREE.Vector3((box.min.x + box.max.x) / 2, box.max.y, (box.min.z + box.max.z) / 2)
            ];
        }
        
        // Update snap lines
        function updateSnapLines() {
            clearSnapLines();
            
            if (!app.movementAxis || app.selectedPieces.size === 0) return;
            
            // Create lines for each selected piece
            app.selectedPieces.forEach(piece => {
                const geometry = new THREE.BufferGeometry();
                const points = [];
                const start = piece.position.clone();
                const end = start.clone();
                
                if (app.movementAxis === 'x') {
                    start.x -= 5;
                    end.x += 5;
                } else if (app.movementAxis === 'y') {
                    start.y -= 5;
                    end.y += 5;
                } else if (app.movementAxis === 'z') {
                    start.z = 0;
                    end.z = 10;
                }
                
                points.push(start, end);
                geometry.setFromPoints(points);
                
                const material = new THREE.LineDashedMaterial({
                    color: 0x2196f3,
                    dashSize: 0.05,
                    gapSize: 0.05,
                    opacity: 0.6,
                    transparent: true
                });
                
                const line = new THREE.Line(geometry, material);
                line.computeLineDistances();
                app.scene.add(line);
                app.snapLines.push(line);
            });
        }
        
        // Clear snap lines
        function clearSnapLines() {
            app.snapLines.forEach(line => {
                app.scene.remove(line);
            });
            app.snapLines = [];
        }
        
        // Adjust piece length
        function adjustLength(event) {
            if (!app.lengthEditPiece || !app.isLengthEditing) return;
            
            const delta = (event.clientX - app.lastMouseX) * 10; // 10mm per pixel
            const sign = app.lengthEditFace === 'top' ? 1 : -1;
            const piece = app.lengthEditPiece;
            const newLength = Math.max(0, piece.userData.length + delta * sign);
            
            // Snap to 10mm increments
            const snappedLength = Math.round(newLength / 10) * 10;
            
            // Update geometry
            const t = piece.userData.thickness / 1000;
            const w = piece.userData.width / 1000;
            const l = snappedLength / 1000;
            
            piece.geometry.dispose();
            piece.geometry = new THREE.BoxGeometry(t, w, l);
            piece.userData.length = snappedLength;
            
            // Adjust position to keep bottom face in place
            if (app.lengthEditFace === 'bottom') {
                piece.position.z = l / 2;
            }
            
            // Show red if will be deleted
            if (snappedLength < 10) {
                piece.material.color.setHex(0xff0000);
            } else {
                piece.material.color.setHex(0x8B6F47);
            }
            
            // Show measurement
            showMeasurement(`Length: ${snappedLength}mm`);
        }
        
        // Duplicate piece
        function duplicatePiece(original) {
            const clone = original.clone();
            clone.material = original.material.clone();
            clone.userData = { ...original.userData };
            
            // Offset slightly
            clone.position.add(new THREE.Vector3(0.1, 0.1, 0.1));
            
            app.scene.add(clone);
            
            // Select the new piece
            clearSelection();
            app.selectedPieces.add(clone);
            updatePieceSelection(clone, true);
            
            saveState();
            saveCurrentProject();
            updateHotkeyGuide();
            showStatus('Duplicated piece');
        }
        
        // Delete selected pieces
        function deleteSelectedPieces() {
            if (app.selectedPieces.size === 0) return;
            
            saveState();
            
            app.selectedPieces.forEach(piece => {
                app.scene.remove(piece);
            });
            
            const count = app.selectedPieces.size;
            app.selectedPieces.clear();
            saveCurrentProject();
            updateHotkeyGuide();
            showStatus(`Deleted ${count} piece${count > 1 ? 's' : ''}`);
        }
        
        // Clear selection
        function clearSelection() {
            app.selectedPieces.forEach(piece => {
                updatePieceSelection(piece, false);
            });
            app.selectedPieces.clear();
        }
        
        // Update piece selection visual
        function updatePieceSelection(piece, selected) {
            if (selected) {
                piece.material.emissive = new THREE.Color(0xff0000);
                piece.material.emissiveIntensity = 0.2;
            } else {
                piece.material.emissive = new THREE.Color(0x000000);
                piece.material.emissiveIntensity = 0;
            }
        }
        
        // Show measurement
        function showMeasurement(text) {
            const measurement = app.measurementElement;
            measurement.textContent = typeof text === 'number' ? `${Math.round(text)}mm` : text;
            measurement.classList.remove('hidden');
            
            clearTimeout(app.measurementTimeout);
            app.measurementTimeout = setTimeout(() => {
                measurement.classList.add('hidden');
            }, 2000);
        }
        
        // Hide measurement
        function hideMeasurement() {
            const measurement = app.measurementElement;
            measurement.classList.add('hidden');
            clearTimeout(app.measurementTimeout);
        }
        
        // Update measurement position
        function updateMeasurementPosition(worldPosition) {
            if (!worldPosition) return;
            
            const screenPosition = worldPosition.clone();
            screenPosition.project(app.camera);
            
            const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;
            
            app.measurementElement.style.left = `${x}px`;
            app.measurementElement.style.top = `${y}px`;
            app.measurementElement.style.transform = 'translate(-50%, -50%)';
        }
        
        // Update hotkey guide
        function updateHotkeyGuide() {
            const movementGuide = document.getElementById('movementGuide');
            const selectedGuide = document.getElementById('selectedGuide');
            
            if (app.movementAxis) {
                movementGuide.style.display = 'block';
                selectedGuide.style.display = 'none';
            } else if (app.selectedPieces.size > 0) {
                movementGuide.style.display = 'none';
                selectedGuide.style.display = 'block';
            } else {
                movementGuide.style.display = 'none';
                selectedGuide.style.display = 'none';
            }
        }
        
        // Project management
        function loadProjects() {
            const saved = localStorage.getItem('woodProjects');
            if (saved) {
                app.projects = JSON.parse(saved);
            } else {
                app.projects = {
                    'Project 1': { pieces: [] }
                };
            }
            
            // Load first project
            const projectNames = Object.keys(app.projects);
            if (projectNames.length > 0) {
                loadProject(projectNames[0]);
            }
            
            updateProjectList();
        }
        
        function saveCurrentProject() {
            if (!app.currentProject) return;
            
            const pieces = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece) {
                    pieces.push({
                        thickness: obj.userData.thickness,
                        width: obj.userData.width,
                        length: obj.userData.length,
                        position: obj.position.toArray(),
                        rotation: obj.rotation.toArray()
                    });
                }
            });
            
            app.projects[app.currentProject] = { pieces };
            localStorage.setItem('woodProjects', JSON.stringify(app.projects));
        }
        
        function loadProject(name) {
            // Clear scene
            const toRemove = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece) {
                    toRemove.push(obj);
                }
            });
            toRemove.forEach(obj => app.scene.remove(obj));
            
            // Clear selection
            clearSelection();
            
            // Load pieces
            const project = app.projects[name];
            if (project && project.pieces) {
                project.pieces.forEach(data => {
                    const t = data.thickness / 1000;
                    const w = data.width / 1000;
                    const l = data.length / 1000;
                    
                    const geometry = new THREE.BoxGeometry(t, w, l);
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x8B6F47,
                        roughness: 0.7,
                        metalness: 0.1
                    });
                    
                    const piece = new THREE.Mesh(geometry, material);
                    piece.castShadow = true;
                    piece.receiveShadow = true;
                    
                    piece.userData = {
                        thickness: data.thickness,
                        width: data.width,
                        length: data.length,
                        isWoodPiece: true
                    };
                    
                    piece.position.fromArray(data.position);
                    piece.rotation.fromArray(data.rotation);
                    
                    app.scene.add(piece);
                });
            }
            
            app.currentProject = name;
            updateProjectList();
            showStatus(`Loaded ${name}`);
        }
        
        function updateProjectList() {
            const projectList = document.getElementById('projectList');
            projectList.innerHTML = '';
            
            Object.keys(app.projects).forEach(name => {
                const item = document.createElement('div');
                item.className = 'project-item';
                if (name === app.currentProject) {
                    item.classList.add('active');
                }
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = name;
                nameSpan.style.cursor = 'pointer';
                nameSpan.onclick = () => {
                    loadProject(name);
                    closeMenu();
                };
                
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteProject(name);
                };
                
                item.appendChild(nameSpan);
                item.appendChild(deleteBtn);
                projectList.appendChild(item);
            });
        }
        
        function createNewProject() {
            const name = prompt('Project name:', `Project ${Object.keys(app.projects).length + 1}`);
            if (name && !app.projects[name]) {
                app.projects[name] = { pieces: [] };
                saveCurrentProject();
                loadProject(name);
            }
        }
        
        function renameProject() {
            if (!app.currentProject) return;
            
            const newName = prompt('New name:', app.currentProject);
            if (newName && newName !== app.currentProject && !app.projects[newName]) {
                app.projects[newName] = app.projects[app.currentProject];
                delete app.projects[app.currentProject];
                app.currentProject = newName;
                localStorage.setItem('woodProjects', JSON.stringify(app.projects));
                updateProjectList();
                showStatus(`Renamed to ${newName}`);
            }
        }
        
        function deleteProject(name) {
            if (Object.keys(app.projects).length <= 1) {
                alert('Cannot delete the last project');
                return;
            }
            
            if (confirm(`Delete project "${name}"?`)) {
                delete app.projects[name];
                
                if (name === app.currentProject) {
                    const remaining = Object.keys(app.projects);
                    if (remaining.length > 0) {
                        loadProject(remaining[0]);
                    }
                }
                
                localStorage.setItem('woodProjects', JSON.stringify(app.projects));
                updateProjectList();
            }
        }
        
        // Undo/Redo functionality
        function saveState() {
            const state = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece) {
                    state.push({
                        thickness: obj.userData.thickness,
                        width: obj.userData.width,
                        length: obj.userData.length,
                        position: obj.position.toArray(),
                        rotation: obj.rotation.toArray()
                    });
                }
            });
            
            app.undoStack.push(state);
            app.redoStack = [];
            
            // Limit stack size
            if (app.undoStack.length > 50) {
                app.undoStack.shift();
            }
        }
        
        function undo() {
            if (app.undoStack.length === 0) return;
            
            const currentState = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece) {
                    currentState.push({
                        thickness: obj.userData.thickness,
                        width: obj.userData.width,
                        length: obj.userData.length,
                        position: obj.position.toArray(),
                        rotation: obj.rotation.toArray()
                    });
                }
            });
            
            app.redoStack.push(currentState);
            
            const previousState = app.undoStack.pop();
            restoreState(previousState);
            showStatus('Undo');
        }
        
        function redo() {
            if (app.redoStack.length === 0) return;
            
            const nextState = app.redoStack.pop();
            saveState();
            restoreState(nextState);
            showStatus('Redo');
        }
        
        function restoreState(state) {
            // Clear current pieces
            const toRemove = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece) {
                    toRemove.push(obj);
                }
            });
            toRemove.forEach(obj => app.scene.remove(obj));
            
            // Clear selection
            clearSelection();
            
            // Restore pieces
            state.forEach(data => {
                const t = data.thickness / 1000;
                const w = data.width / 1000;
                const l = data.length / 1000;
                
                const geometry = new THREE.BoxGeometry(t, w, l);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x8B6F47,
                    roughness: 0.7,
                    metalness: 0.1
                });
                
                const piece = new THREE.Mesh(geometry, material);
                piece.castShadow = true;
                piece.receiveShadow = true;
                
                piece.userData = {
                    thickness: data.thickness,
                    width: data.width,
                    length: data.length,
                    isWoodPiece: true
                };
                
                piece.position.fromArray(data.position);
                piece.rotation.fromArray(data.rotation);
                
                app.scene.add(piece);
            });
            
            saveCurrentProject();
            updateHotkeyGuide();
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            app.renderer.render(app.scene, app.camera);
        }
        
        // Initialize on load
        window.addEventListener('load', init);
        
        // Expose app functions to window for UI
        window.app = app;
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Wood Construction</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            user-select: none;
            background: #1a1a1a;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        #canvas.grabbing {
            cursor: grabbing;
        }
        
        /* Hamburger Menu Button */
        .menu-button {
            position: fixed;
            left: 20px;
            top: 20px;
            width: 40px;
            height: 40px;
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            z-index: 1001;
            transition: all 0.2s;
        }
        
        .menu-button:hover {
            background: rgba(60, 60, 60, 0.9);
        }
        
        .menu-button span {
            width: 24px;
            height: 2px;
            background: #fff;
            transition: all 0.3s;
        }
        
        .menu-button.active span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }
        
        .menu-button.active span:nth-child(2) {
            opacity: 0;
        }
        
        .menu-button.active span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }
        
        /* Material Selection Panel */
        .material-panel {
            position: fixed;
            left: -300px;
            top: 0;
            background: rgba(40, 40, 40, 0.95);
            height: 100vh;
            width: 280px;
            padding: 80px 20px 20px;
            box-shadow: 2px 0 20px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
            transition: left 0.3s ease;
            z-index: 1000;
        }
        
        .material-panel.active {
            left: 0;
        }
        
        .material-panel h3 {
            font-size: 14px;
            margin-bottom: 15px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .thickness-group {
            margin-bottom: 20px;
        }
        
        .thickness-group h4 {
            font-size: 12px;
            color: #999;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .wood-option {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 6px 0;
            background: rgba(60, 60, 60, 0.6);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        
        .wood-option:hover {
            background: rgba(80, 80, 80, 0.6);
            transform: translateX(4px);
        }
        
        .wood-option.active {
            background: rgba(33, 150, 243, 0.2);
            border-color: #2196f3;
        }
        
        .wood-icon {
            width: 40px;
            height: 40px;
            margin-right: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            background: #2a2a2a;
        }
        
        .wood-label {
            font-size: 13px;
            font-weight: 500;
            color: #fff;
        }
        
        /* Overlay for closing menu */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 999;
            display: none;
        }
        
        .menu-overlay.active {
            display: block;
        }
        
        /* Project Controls */
        .project-panel {
            position: fixed;
            right: 20px;
            top: 20px;
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            width: 200px;
        }
        
        .project-panel h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .project-list {
            margin-bottom: 10px;
        }
        
        .project-item {
            padding: 8px 10px;
            margin: 4px 0;
            background: rgba(60, 60, 60, 0.6);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #fff;
            transition: all 0.2s;
        }
        
        .project-item:hover {
            background: rgba(80, 80, 80, 0.6);
        }
        
        .project-item.active {
            background: rgba(33, 150, 243, 0.2);
            font-weight: 500;
            border: 1px solid #2196f3;
        }
        
        .project-item button {
            padding: 2px 6px;
            font-size: 10px;
            background: #d32f2f;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .project-item button:hover {
            background: #b71c1c;
        }
        
        .project-controls button {
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .project-controls button:hover {
            background: #1976d2;
        }
        
        /* Hotkey Guide */
        .hotkey-guide {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 11px;
            transition: opacity 0.3s;
        }
        
        .hotkey-guide.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .hotkey-group {
            margin-bottom: 10px;
        }
        
        .hotkey-group h4 {
            font-size: 12px;
            margin-bottom: 5px;
            color: #4fc3f7;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .hotkey {
            display: flex;
            margin: 3px 0;
            color: #ccc;
        }
        
        .hotkey-key {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 8px;
            font-family: monospace;
            min-width: 20px;
            text-align: center;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Measurement Display */
        .measurement {
            position: fixed;
            background: rgba(33, 150, 243, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .measurement.hidden {
            opacity: 0;
        }
        
        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #999;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading 3D environment...</div>
    <canvas id="canvas"></canvas>
    
    <!-- Hamburger Menu Button -->
    <div class="menu-button" id="menuButton" onclick="toggleMenu()">
        <span></span>
        <span></span>
        <span></span>
    </div>
    
    <!-- Menu Overlay -->
    <div class="menu-overlay" id="menuOverlay" onclick="closeMenu()"></div>
    
    <!-- Material Selection Panel -->
    <div class="material-panel" id="materialPanel">
        <h3>Wood Materials</h3>
        <div id="materialList"></div>
    </div>
    
    <!-- Project Panel -->
    <div class="project-panel">
        <h3>Projects</h3>
        <div class="project-list" id="projectList"></div>
        <div class="project-controls">
            <button onclick="app.createNewProject()">New Project</button>
            <button onclick="app.renameProject()">Rename</button>
        </div>
    </div>
    
    <!-- Hotkey Guide -->
    <div class="hotkey-guide" id="hotkeyGuide">
        <div class="hotkey-group" id="activeGuide" style="display: none;">
            <h4>Active Piece</h4>
            <div class="hotkey"><span class="hotkey-key">Z</span> Move along Z axis (hold)</div>
            <div class="hotkey"><span class="hotkey-key">X</span> Move along X axis (hold)</div>
            <div class="hotkey"><span class="hotkey-key">C</span> Move along Y axis (hold)</div>
            <div class="hotkey"><span class="hotkey-key">V</span> + Click end to adjust length</div>
            <div class="hotkey"><span class="hotkey-key">A</span> Rotate around Z</div>
            <div class="hotkey"><span class="hotkey-key">S</span> Rotate around X</div>
            <div class="hotkey"><span class="hotkey-key">D</span> Rotate around Y</div>
            <div class="hotkey"><span class="hotkey-key">Backspace</span> Cancel</div>
        </div>
        <div class="hotkey-group" id="selectedGuide" style="display: none;">
            <h4>Selected Pieces</h4>
            <div class="hotkey"><span class="hotkey-key">E</span> + Click to duplicate</div>
            <div class="hotkey"><span class="hotkey-key">T</span> Delete selected</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl</span> + Click to multi-select</div>
        </div>
        <div class="hotkey-group" id="generalGuide">
            <h4>General</h4>
            <div class="hotkey"><span class="hotkey-key">Left Click</span> Pan camera</div>
            <div class="hotkey"><span class="hotkey-key">Right Click</span> Orbit camera</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl+Z</span> Undo</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl+Y</span> Redo</div>
            <div class="hotkey"><span class="hotkey-key">1-0</span> Quick material select</div>
        </div>
    </div>
    
    <!-- Measurement Display -->
    <div class="measurement hidden" id="measurement"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global app object
        const app = {
            scene: null,
            camera: null,
            renderer: null,
            raycaster: new THREE.Raycaster(),
            mouse: new THREE.Vector2(),
            
            // State
            activePiece: null,
            selectedPieces: new Set(),
            movementAxis: null,
            isLengthEditing: false,
            lengthEditFace: null,
            
            // Input state
            keys: {},
            mouseDown: false,
            rightMouseDown: false,
            lastMouseX: 0,
            lastMouseY: 0,
            
            // Camera state
            cameraDistance: 3,
            cameraTheta: Math.PI / 4,
            cameraPhi: Math.PI / 3,
            cameraTarget: new THREE.Vector3(0, 0, 0),
            
            // Wood dimensions (thickness x width in mm)
            woodDimensions: [
                // Group by thickness
                { thickness: 20, widths: [48, 73, 98, 120] },
                { thickness: 28, widths: [48, 73, 98, 120] },
                { thickness: 36, widths: [48, 73, 98, 120] },
                { thickness: 48, widths: [48, 73, 98, 120] },
                { thickness: 98, widths: [48, 73, 98, 120] }
            ],
            
            selectedDimension: null,
            recentDimensions: [],
            
            // Project management
            projects: {},
            currentProject: null,
            
            // Undo/Redo
            undoStack: [],
            redoStack: [],
            
            // Visual helpers
            snapLine: null,
            measurementTimeout: null,
            measurementElement: null
        };
        
        // Menu toggle functions
        function toggleMenu() {
            const panel = document.getElementById('materialPanel');
            const button = document.getElementById('menuButton');
            const overlay = document.getElementById('menuOverlay');
            
            panel.classList.toggle('active');
            button.classList.toggle('active');
            overlay.classList.toggle('active');
        }
        
        function closeMenu() {
            const panel = document.getElementById('materialPanel');
            const button = document.getElementById('menuButton');
            const overlay = document.getElementById('menuOverlay');
            
            panel.classList.remove('active');
            button.classList.remove('active');
            overlay.classList.remove('active');
        }
        
        // Initialize the application
        function init() {
            // Setup Three.js
            app.scene = new THREE.Scene();
            app.scene.background = new THREE.Color(0x1a1a1a);
            app.scene.fog = new THREE.Fog(0x1a1a1a, 10, 50);
            
            // Camera setup (Z is up)
            app.camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            updateCameraPosition();
            
            // Renderer
            const canvas = document.getElementById('canvas');
            app.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            app.renderer.setSize(window.innerWidth, window.innerHeight);
            app.renderer.shadowMap.enabled = true;
            app.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            app.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, -5, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            app.scene.add(directionalLight);
            
            // Ground plane (solid gray)
            const groundGeometry = new THREE.BoxGeometry(40, 40, 0.1);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a4a4a,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.position.z = -0.05;
            ground.receiveShadow = true;
            ground.userData.isGround = true;
            app.scene.add(ground);
            
            // Add subtle grid on top of ground
            const gridHelper = new THREE.GridHelper(40, 80, 0x555555, 0x3a3a3a);
            gridHelper.rotation.x = Math.PI / 2;
            gridHelper.position.z = 0.001;
            app.scene.add(gridHelper);
            
            // Initialize UI
            initializeMaterialPanel();
            loadProjects();
            
            // Create measurement element
            app.measurementElement = document.getElementById('measurement');
            
            // Event listeners
            setupEventListeners();
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Start render loop
            animate();
        }
        
        // Update camera position based on spherical coordinates
        function updateCameraPosition() {
            app.camera.position.x = app.cameraTarget.x + app.cameraDistance * Math.sin(app.cameraTheta) * Math.sin(app.cameraPhi);
            app.camera.position.y = app.cameraTarget.y + app.cameraDistance * Math.cos(app.cameraTheta) * Math.sin(app.cameraPhi);
            app.camera.position.z = app.cameraTarget.z + app.cameraDistance * Math.cos(app.cameraPhi);
            app.camera.lookAt(app.cameraTarget);
        }
        
        // Initialize material selection panel
        function initializeMaterialPanel() {
            const materialList = document.getElementById('materialList');
            
            app.woodDimensions.forEach((group, groupIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'thickness-group';
                
                const groupTitle = document.createElement('h4');
                groupTitle.textContent = `${group.thickness}mm Thickness`;
                groupDiv.appendChild(groupTitle);
                
                group.widths.forEach((width, widthIndex) => {
                    const option = document.createElement('div');
                    option.className = 'wood-option';
                    option.dataset.thickness = group.thickness;
                    option.dataset.width = width;
                    
                    // Create visual icon (1:10 scale)
                    const icon = document.createElement('canvas');
                    icon.className = 'wood-icon';
                    icon.width = 40;
                    icon.height = 40;
                    const ctx = icon.getContext('2d');
                    
                    // Draw cross-section at 1:10 scale
                    const scale = 0.3;
                    const t = group.thickness * scale;
                    const w = width * scale;
                    
                    ctx.fillStyle = '#8B6F47';
                    ctx.fillRect(
                        (40 - t) / 2,
                        (40 - w) / 2,
                        t,
                        w
                    );
                    
                    ctx.strokeStyle = '#6B5637';
                    ctx.strokeRect(
                        (40 - t) / 2,
                        (40 - w) / 2,
                        t,
                        w
                    );
                    
                    const label = document.createElement('div');
                    label.className = 'wood-label';
                    label.textContent = `${group.thickness}×${width}mm`;
                    
                    option.appendChild(icon);
                    option.appendChild(label);
                    
                    option.addEventListener('click', () => {
                        selectWoodDimension(group.thickness, width);
                        closeMenu();
                    });
                    
                    groupDiv.appendChild(option);
                });
                
                materialList.appendChild(groupDiv);
            });
        }
        
        // Select wood dimension
        function selectWoodDimension(thickness, width) {
            // Update UI
            document.querySelectorAll('.wood-option').forEach(opt => {
                opt.classList.remove('active');
            });
            
            const selected = document.querySelector(
                `.wood-option[data-thickness="${thickness}"][data-width="${width}"]`
            );
            if (selected) {
                selected.classList.add('active');
            }
            
            app.selectedDimension = { thickness, width };
            
            // Update recent dimensions
            const key = `${thickness}x${width}`;
            app.recentDimensions = app.recentDimensions.filter(d => d !== key);
            app.recentDimensions.unshift(key);
            if (app.recentDimensions.length > 10) {
                app.recentDimensions.pop();
            }
            
            // Create new wood piece
            createWoodPiece(thickness, width);
        }
        
        // Create wood piece
        function createWoodPiece(thickness, width, length = 500) {
            // Cancel current active piece if exists
            if (app.activePiece) {
                app.scene.remove(app.activePiece);
            }
            
            // Convert mm to scene units (1 unit = 1 meter)
            const t = thickness / 1000;
            const w = width / 1000;
            const l = length / 1000;
            
            // Create geometry with rounded edges effect
            const geometry = new THREE.BoxGeometry(t, w, l);
            const material = new THREE.MeshStandardMaterial({
                color: 0x8B6F47,
                roughness: 0.7,
                metalness: 0.1
            });
            
            const piece = new THREE.Mesh(geometry, material);
            piece.castShadow = true;
            piece.receiveShadow = true;
            
            // Store dimensions in userData
            piece.userData = {
                thickness,
                width,
                length,
                isWoodPiece: true,
                isActive: true
            };
            
            // Position on the floor
            piece.position.set(
                app.cameraTarget.x,
                app.cameraTarget.y,
                l / 2
            );
            
            // Add to scene
            app.scene.add(piece);
            app.activePiece = piece;
            
            // Update hotkey guide
            updateHotkeyGuide();
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', onWindowResize);
            
            // Mouse events
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('contextmenu', e => e.preventDefault());
            
            // Keyboard events
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Mouse wheel
            document.addEventListener('wheel', onMouseWheel);
        }
        
        // Window resize handler
        function onWindowResize() {
            app.camera.aspect = window.innerWidth / window.innerHeight;
            app.camera.updateProjectionMatrix();
            app.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Mouse down handler
        function onMouseDown(event) {
            if (event.target.id !== 'canvas') return;
            
            if (event.button === 0) {
                app.mouseDown = true;
                
                // Check for V key for length editing
                if (app.keys['v'] && app.activePiece) {
                    // Check if clicking on end face
                    updateMouse(event);
                    app.raycaster.setFromCamera(app.mouse, app.camera);
                    const intersects = app.raycaster.intersectObject(app.activePiece);
                    
                    if (intersects.length > 0) {
                        const face = intersects[0].face;
                        const normal = face.normal.clone();
                        normal.transformDirection(app.activePiece.matrixWorld);
                        
                        // Check if clicking on Z-aligned face (end faces)
                        if (Math.abs(normal.z) > 0.9) {
                            app.isLengthEditing = true;
                            app.lengthEditFace = normal.z > 0 ? 'top' : 'bottom';
                        }
                    }
                } else {
                    // Check for object interaction
                    updateMouse(event);
                    checkIntersection(event);
                }
                
            } else if (event.button === 2) {
                app.rightMouseDown = true;
            }
            
            app.lastMouseX = event.clientX;
            app.lastMouseY = event.clientY;
            
            document.getElementById('canvas').classList.add('grabbing');
        }
        
        // Mouse move handler
        function onMouseMove(event) {
            const deltaX = event.clientX - app.lastMouseX;
            const deltaY = event.clientY - app.lastMouseY;
            
            if (app.activePiece && app.movementAxis) {
                // Move active piece along axis
                moveAlongAxis(event);
            } else if (app.activePiece && app.isLengthEditing) {
                // Adjust length
                adjustLength(event);
            } else if (app.mouseDown && !app.keys['z'] && !app.keys['x'] && !app.keys['c'] && !app.keys['v']) {
                // Camera panning
                const panSpeed = 0.003;
                const right = new THREE.Vector3();
                const forward = new THREE.Vector3();
                
                app.camera.getWorldDirection(forward);
                forward.z = 0;
                forward.normalize();
                right.crossVectors(forward, new THREE.Vector3(0, 0, 1)).normalize();
                
                app.cameraTarget.add(right.multiplyScalar(-deltaX * panSpeed));
                app.cameraTarget.add(forward.multiplyScalar(deltaY * panSpeed));
                updateCameraPosition();
                
            } else if (app.rightMouseDown) {
                // Camera orbiting (no head tilting)
                const orbitSpeed = 0.005;
                app.cameraTheta -= deltaX * orbitSpeed;
                app.cameraPhi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, app.cameraPhi)); // Prevent tilting past horizontal
                
                updateCameraPosition();
            }
            
            app.lastMouseX = event.clientX;
            app.lastMouseY = event.clientY;
            
            updateMouse(event);
        }
        
        // Mouse up handler
        function onMouseUp(event) {
            if (event.button === 0) {
                app.mouseDown = false;
                
                if (app.activePiece && !app.movementAxis && !app.isLengthEditing) {
                    // Place the piece
                    placeActivePiece();
                }
                
                app.isLengthEditing = false;
                app.lengthEditFace = null;
                
            } else if (event.button === 2) {
                app.rightMouseDown = false;
            }
            
            document.getElementById('canvas').classList.remove('grabbing');
            
            // Clear snap line
            if (app.snapLine) {
                app.scene.remove(app.snapLine);
                app.snapLine = null;
            }
            
            // Hide measurement
            hideMeasurement();
        }
        
        // Key down handler
        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            app.keys[key] = true;
            
            // Movement axis controls - set axis while key is held
            if (app.activePiece && app.mouseDown) {
                if (key === 'z') {
                    app.movementAxis = 'z';
                    updateSnapLine();
                } else if (key === 'x') {
                    app.movementAxis = 'x';
                    updateSnapLine();
                } else if (key === 'c') {
                    app.movementAxis = 'y';
                    updateSnapLine();
                }
            }
            
            // Rotation controls
            if (app.activePiece && !event.repeat) {
                if (key === 'a') {
                    rotatePiece(app.activePiece, 'z');
                } else if (key === 's') {
                    rotatePiece(app.activePiece, 'x');
                } else if (key === 'd') {
                    rotatePiece(app.activePiece, 'y');
                }
            }
            
            // Cancel placement
            if (key === 'backspace' && app.activePiece) {
                app.scene.remove(app.activePiece);
                app.activePiece = null;
                updateHotkeyGuide();
                hideMeasurement();
            }
            
            // Selection controls
            if (key === 't' && app.selectedPieces.size > 0) {
                deleteSelectedPieces();
            }
            
            // Undo/Redo
            if (event.ctrlKey) {
                if (key === 'z') {
                    event.preventDefault();
                    undo();
                } else if (key === 'y') {
                    event.preventDefault();
                    redo();
                }
            }
            
            // Quick material selection (1-0 keys)
            const numKey = parseInt(event.key);
            if (!isNaN(numKey) && numKey >= 0 && numKey <= 9) {
                const index = numKey === 0 ? 9 : numKey - 1;
                if (app.recentDimensions[index]) {
                    const [thickness, width] = app.recentDimensions[index].split('x').map(Number);
                    selectWoodDimension(thickness, width);
                }
            }
        }
        
        // Key up handler
        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            delete app.keys[key];
            
            // Clear movement axis when key released
            if ((key === 'z' && app.movementAxis === 'z') ||
                (key === 'x' && app.movementAxis === 'x') ||
                (key === 'c' && app.movementAxis === 'y')) {
                app.movementAxis = null;
                
                // Clear snap line
                if (app.snapLine) {
                    app.scene.remove(app.snapLine);
                    app.snapLine = null;
                }
                
                hideMeasurement();
            }
        }
        
        // Mouse wheel handler
        function onMouseWheel(event) {
            const zoomSpeed = 0.001;
            app.cameraDistance += event.deltaY * zoomSpeed;
            app.cameraDistance = Math.max(0.5, Math.min(20, app.cameraDistance));
            updateCameraPosition();
        }
        
        // Update mouse position
        function updateMouse(event) {
            app.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            app.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        
        // Check for intersections
        function checkIntersection(event) {
            app.raycaster.setFromCamera(app.mouse, app.camera);
            
            const objects = app.scene.children.filter(obj => 
                obj.userData.isWoodPiece && !obj.userData.isActive
            );
            
            const intersects = app.raycaster.intersectObjects(objects);
            
            if (intersects.length > 0) {
                const piece = intersects[0].object;
                
                if (app.keys['e']) {
                    // Duplicate
                    duplicatePiece(piece);
                } else if (event.ctrlKey) {
                    // Multi-select
                    if (app.selectedPieces.has(piece)) {
                        app.selectedPieces.delete(piece);
                        updatePieceSelection(piece, false);
                    } else {
                        app.selectedPieces.add(piece);
                        updatePieceSelection(piece, true);
                    }
                } else {
                    // Single select
                    clearSelection();
                    app.selectedPieces.add(piece);
                    updatePieceSelection(piece, true);
                }
                
                updateHotkeyGuide();
            } else {
                // Click on empty space - clear selection
                clearSelection();
                updateHotkeyGuide();
            }
        }
        
        // Move piece along axis
        function moveAlongAxis(event) {
            if (!app.activePiece || !app.movementAxis) return;
            
            const movementSpeed = 0.002;
            const delta = event.clientX - app.lastMouseX;
            
            const movement = new THREE.Vector3();
            if (app.movementAxis === 'x') {
                movement.x = delta * movementSpeed;
            } else if (app.movementAxis === 'y') {
                movement.y = delta * movementSpeed;
            } else if (app.movementAxis === 'z') {
                movement.z = -delta * movementSpeed;
            }
            
            app.activePiece.position.add(movement);
            
            // Check collisions and snap
            const snapInfo = checkCollisionAndSnap();
            
            // Update measurement display position
            if (snapInfo && snapInfo.distance !== null) {
                updateMeasurementPosition(snapInfo.position);
            }
        }
        
        // Check collision and snap
        function checkCollisionAndSnap() {
            if (!app.activePiece) return null;
            
            const box = new THREE.Box3().setFromObject(app.activePiece);
            const snapThreshold = 0.01; // 10mm
            
            let hasCollision = false;
            let snapPosition = null;
            let minDistance = Infinity;
            let measurementPosition = null;
            
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece && obj !== app.activePiece) {
                    const targetBox = new THREE.Box3().setFromObject(obj);
                    
                    if (box.intersectsBox(targetBox)) {
                        hasCollision = true;
                        
                        // For vertical movement, allow overlap but show red
                        if (app.movementAxis === 'z') {
                            app.activePiece.material.color.setHex(0xff0000);
                        } else {
                            // Push up to top of collided piece
                            const overlap = box.min.z - targetBox.max.z;
                            if (overlap < 0) {
                                app.activePiece.position.z -= overlap;
                            }
                        }
                    }
                    
                    // Check for snap points
                    if (app.movementAxis) {
                        const corners = getBoxCorners(targetBox);
                        corners.forEach(corner => {
                            const distance = corner[app.movementAxis] - app.activePiece.position[app.movementAxis];
                            if (Math.abs(distance) < snapThreshold && Math.abs(distance) < Math.abs(minDistance)) {
                                minDistance = distance;
                                snapPosition = corner[app.movementAxis];
                                
                                // Calculate measurement position (midpoint along axis)
                                measurementPosition = app.activePiece.position.clone();
                                measurementPosition[app.movementAxis] = (app.activePiece.position[app.movementAxis] + corner[app.movementAxis]) / 2;
                            }
                        });
                    }
                }
            });
            
            // Apply snap
            if (snapPosition !== null) {
                app.activePiece.position[app.movementAxis] = snapPosition;
            }
            
            // Reset color if no collision
            if (!hasCollision) {
                app.activePiece.material.color.setHex(0x8B6F47);
            }
            
            // Show measurement
            if (Math.abs(minDistance) < Infinity) {
                showMeasurement(Math.abs(minDistance) * 1000); // Convert to mm
                return { distance: minDistance, position: measurementPosition };
            }
            
            return null;
        }
        
        // Get box corners
        function getBoxCorners(box) {
            return [
                new THREE.Vector3(box.min.x, box.min.y, box.min.z),
                new THREE.Vector3(box.max.x, box.min.y, box.min.z),
                new THREE.Vector3(box.min.x, box.max.y, box.min.z),
                new THREE.Vector3(box.max.x, box.max.y, box.min.z),
                new THREE.Vector3(box.min.x, box.min.y, box.max.z),
                new THREE.Vector3(box.max.x, box.min.y, box.max.z),
                new THREE.Vector3(box.min.x, box.max.y, box.max.z),
                new THREE.Vector3(box.max.x, box.max.y, box.max.z),
                // Add midpoints
                new THREE.Vector3((box.min.x + box.max.x) / 2, (box.min.y + box.max.y) / 2, box.min.z),
                new THREE.Vector3((box.min.x + box.max.x) / 2, (box.min.y + box.max.y) / 2, box.max.z),
                new THREE.Vector3(box.min.x, (box.min.y + box.max.y) / 2, (box.min.z + box.max.z) / 2),
                new THREE.Vector3(box.max.x, (box.min.y + box.max.y) / 2, (box.min.z + box.max.z) / 2),
                new THREE.Vector3((box.min.x + box.max.x) / 2, box.min.y, (box.min.z + box.max.z) / 2),
                new THREE.Vector3((box.min.x + box.max.x) / 2, box.max.y, (box.min.z + box.max.z) / 2)
            ];
        }
        
        // Update snap line
        function updateSnapLine() {
            if (!app.activePiece || !app.movementAxis) {
                if (app.snapLine) {
                    app.scene.remove(app.snapLine);
                    app.snapLine = null;
                }
                return;
            }
            
            // Remove existing line
            if (app.snapLine) {
                app.scene.remove(app.snapLine);
            }
            
            // Create stippled line along movement axis
            const geometry = new THREE.BufferGeometry();
            const points = [];
            const start = app.activePiece.position.clone();
            const end = start.clone();
            
            if (app.movementAxis === 'x') {
                start.x -= 5;
                end.x += 5;
            } else if (app.movementAxis === 'y') {
                start.y -= 5;
                end.y += 5;
            } else if (app.movementAxis === 'z') {
                start.z = 0;
                end.z = 10;
            }
            
            points.push(start, end);
            geometry.setFromPoints(points);
            
            const material = new THREE.LineDashedMaterial({
                color: 0x2196f3,
                dashSize: 0.05,
                gapSize: 0.05,
                opacity: 0.8,
                transparent: true
            });
            
            app.snapLine = new THREE.Line(geometry, material);
            app.snapLine.computeLineDistances();
            app.scene.add(app.snapLine);
        }
        
        // Adjust piece length
        function adjustLength(event) {
            if (!app.activePiece || !app.isLengthEditing) return;
            
            const delta = (event.clientX - app.lastMouseX) * 10; // 10mm per pixel
            const sign = app.lengthEditFace === 'top' ? 1 : -1;
            const newLength = Math.max(0, app.activePiece.userData.length + delta * sign);
            
            // Snap to 10mm increments
            const snappedLength = Math.round(newLength / 10) * 10;
            
            // Update geometry
            const t = app.activePiece.userData.thickness / 1000;
            const w = app.activePiece.userData.width / 1000;
            const l = snappedLength / 1000;
            
            app.activePiece.geometry.dispose();
            app.activePiece.geometry = new THREE.BoxGeometry(t, w, l);
            app.activePiece.userData.length = snappedLength;
            
            // Adjust position to keep bottom face in place
            if (app.lengthEditFace === 'bottom') {
                app.activePiece.position.z = l / 2;
            }
            
            // Show red if will be deleted
            if (snappedLength < 10) {
                app.activePiece.material.color.setHex(0xff0000);
            } else {
                app.activePiece.material.color.setHex(0x8B6F47);
            }
            
            // Show measurement
            showMeasurement(`Length: ${snappedLength}mm`);
        }
        
        // Rotate piece
        function rotatePiece(piece, axis) {
            const rotation = Math.PI / 2;
            
            if (axis === 'x') {
                piece.rotateX(rotation);
            } else if (axis === 'y') {
                piece.rotateY(rotation);
            } else if (axis === 'z') {
                piece.rotateZ(rotation);
            }
            
            checkCollisionAndSnap();
        }
        
        // Place active piece
        function placeActivePiece() {
            if (!app.activePiece) return;
            
            // Check if valid position (not red)
            if (app.activePiece.material.color.getHex() === 0xff0000) {
                // Cancel placement
                app.scene.remove(app.activePiece);
                app.activePiece = null;
                updateHotkeyGuide();
                return;
            }
            
            // Mark as placed
            app.activePiece.userData.isActive = false;
            
            // Save state for undo
            saveState();
            
            // Clear active piece
            app.activePiece = null;
            app.movementAxis = null;
            
            // Save project
            saveCurrentProject();
            
            updateHotkeyGuide();
        }
        
        // Duplicate piece
        function duplicatePiece(original) {
            const clone = original.clone();
            clone.material = original.material.clone();
            clone.userData = { ...original.userData };
            clone.userData.isActive = true;
            
            // Offset slightly
            clone.position.add(new THREE.Vector3(0.1, 0.1, 0.1));
            
            app.scene.add(clone);
            app.activePiece = clone;
            
            updateHotkeyGuide();
        }
        
        // Delete selected pieces
        function deleteSelectedPieces() {
            saveState();
            
            app.selectedPieces.forEach(piece => {
                app.scene.remove(piece);
            });
            
            app.selectedPieces.clear();
            saveCurrentProject();
            updateHotkeyGuide();
        }
        
        // Clear selection
        function clearSelection() {
            app.selectedPieces.forEach(piece => {
                updatePieceSelection(piece, false);
            });
            app.selectedPieces.clear();
        }
        
        // Update piece selection visual
        function updatePieceSelection(piece, selected) {
            if (selected) {
                // Create outline effect with emissive
                piece.material.emissive = new THREE.Color(0xff0000);
                piece.material.emissiveIntensity = 0.2;
            } else {
                piece.material.emissive = new THREE.Color(0x000000);
                piece.material.emissiveIntensity = 0;
            }
        }
        
        // Show measurement
        function showMeasurement(text) {
            const measurement = app.measurementElement;
            measurement.textContent = typeof text === 'number' ? `${Math.round(text)}mm` : text;
            measurement.classList.remove('hidden');
            
            clearTimeout(app.measurementTimeout);
            app.measurementTimeout = setTimeout(() => {
                measurement.classList.add('hidden');
            }, 2000);
        }
        
        // Hide measurement
        function hideMeasurement() {
            const measurement = app.measurementElement;
            measurement.classList.add('hidden');
            clearTimeout(app.measurementTimeout);
        }
        
        // Update measurement position
        function updateMeasurementPosition(worldPosition) {
            if (!worldPosition) return;
            
            const screenPosition = worldPosition.clone();
            screenPosition.project(app.camera);
            
            const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;
            
            app.measurementElement.style.left = `${x}px`;
            app.measurementElement.style.top = `${y}px`;
            app.measurementElement.style.transform = 'translate(-50%, -50%)';
        }
        
        // Update hotkey guide
        function updateHotkeyGuide() {
            const activeGuide = document.getElementById('activeGuide');
            const selectedGuide = document.getElementById('selectedGuide');
            
            if (app.activePiece) {
                activeGuide.style.display = 'block';
                selectedGuide.style.display = 'none';
            } else if (app.selectedPieces.size > 0) {
                activeGuide.style.display = 'none';
                selectedGuide.style.display = 'block';
            } else {
                activeGuide.style.display = 'none';
                selectedGuide.style.display = 'none';
            }
        }
        
        // Project management
        function loadProjects() {
            const saved = localStorage.getItem('woodProjects');
            if (saved) {
                app.projects = JSON.parse(saved);
            } else {
                app.projects = {
                    'Project 1': { pieces: [] }
                };
            }
            
            // Load first project
            const projectNames = Object.keys(app.projects);
            if (projectNames.length > 0) {
                loadProject(projectNames[0]);
            }
            
            updateProjectList();
        }
        
        function saveCurrentProject() {
            if (!app.currentProject) return;
            
            const pieces = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece && !obj.userData.isActive) {
                    pieces.push({
                        thickness: obj.userData.thickness,
                        width: obj.userData.width,
                        length: obj.userData.length,
                        position: obj.position.toArray(),
                        rotation: obj.rotation.toArray()
                    });
                }
            });
            
            app.projects[app.currentProject] = { pieces };
            localStorage.setItem('woodProjects', JSON.stringify(app.projects));
        }
        
        function loadProject(name) {
            // Clear scene
            const toRemove = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece) {
                    toRemove.push(obj);
                }
            });
            toRemove.forEach(obj => app.scene.remove(obj));
            
            // Clear selection
            clearSelection();
            
            // Load pieces
            const project = app.projects[name];
            if (project && project.pieces) {
                project.pieces.forEach(data => {
                    const t = data.thickness / 1000;
                    const w = data.width / 1000;
                    const l = data.length / 1000;
                    
                    const geometry = new THREE.BoxGeometry(t, w, l);
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x8B6F47,
                        roughness: 0.7,
                        metalness: 0.1
                    });
                    
                    const piece = new THREE.Mesh(geometry, material);
                    piece.castShadow = true;
                    piece.receiveShadow = true;
                    
                    piece.userData = {
                        thickness: data.thickness,
                        width: data.width,
                        length: data.length,
                        isWoodPiece: true,
                        isActive: false
                    };
                    
                    piece.position.fromArray(data.position);
                    piece.rotation.fromArray(data.rotation);
                    
                    app.scene.add(piece);
                });
            }
            
            app.currentProject = name;
            updateProjectList();
        }
        
        function updateProjectList() {
            const projectList = document.getElementById('projectList');
            projectList.innerHTML = '';
            
            Object.keys(app.projects).forEach(name => {
                const item = document.createElement('div');
                item.className = 'project-item';
                if (name === app.currentProject) {
                    item.classList.add('active');
                }
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = name;
                nameSpan.style.cursor = 'pointer';
                nameSpan.onclick = () => loadProject(name);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteProject(name);
                };
                
                item.appendChild(nameSpan);
                item.appendChild(deleteBtn);
                projectList.appendChild(item);
            });
        }
        
        function createNewProject() {
            const name = prompt('Project name:', `Project ${Object.keys(app.projects).length + 1}`);
            if (name && !app.projects[name]) {
                app.projects[name] = { pieces: [] };
                saveCurrentProject();
                loadProject(name);
            }
        }
        
        function renameProject() {
            if (!app.currentProject) return;
            
            const newName = prompt('New name:', app.currentProject);
            if (newName && newName !== app.currentProject && !app.projects[newName]) {
                app.projects[newName] = app.projects[app.currentProject];
                delete app.projects[app.currentProject];
                app.currentProject = newName;
                localStorage.setItem('woodProjects', JSON.stringify(app.projects));
                updateProjectList();
            }
        }
        
        function deleteProject(name) {
            if (Object.keys(app.projects).length <= 1) {
                alert('Cannot delete the last project');
                return;
            }
            
            if (confirm(`Delete project "${name}"?`)) {
                delete app.projects[name];
                
                if (name === app.currentProject) {
                    const remaining = Object.keys(app.projects);
                    if (remaining.length > 0) {
                        loadProject(remaining[0]);
                    }
                }
                
                localStorage.setItem('woodProjects', JSON.stringify(app.projects));
                updateProjectList();
            }
        }
        
        // Undo/Redo functionality
        function saveState() {
            const state = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece && !obj.userData.isActive) {
                    state.push({
                        thickness: obj.userData.thickness,
                        width: obj.userData.width,
                        length: obj.userData.length,
                        position: obj.position.toArray(),
                        rotation: obj.rotation.toArray()
                    });
                }
            });
            
            app.undoStack.push(state);
            app.redoStack = [];
            
            // Limit stack size
            if (app.undoStack.length > 50) {
                app.undoStack.shift();
            }
        }
        
        function undo() {
            if (app.undoStack.length === 0) return;
            
            const currentState = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece && !obj.userData.isActive) {
                    currentState.push({
                        thickness: obj.userData.thickness,
                        width: obj.userData.width,
                        length: obj.userData.length,
                        position: obj.position.toArray(),
                        rotation: obj.rotation.toArray()
                    });
                }
            });
            
            app.redoStack.push(currentState);
            
            const previousState = app.undoStack.pop();
            restoreState(previousState);
        }
        
        function redo() {
            if (app.redoStack.length === 0) return;
            
            const nextState = app.redoStack.pop();
            saveState();
            restoreState(nextState);
        }
        
        function restoreState(state) {
            // Clear current pieces
            const toRemove = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece && !obj.userData.isActive) {
                    toRemove.push(obj);
                }
            });
            toRemove.forEach(obj => app.scene.remove(obj));
            
            // Clear selection
            clearSelection();
            
            // Restore pieces
            state.forEach(data => {
                const t = data.thickness / 1000;
                const w = data.width / 1000;
                const l = data.length / 1000;
                
                const geometry = new THREE.BoxGeometry(t, w, l);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x8B6F47,
                    roughness: 0.7,
                    metalness: 0.1
                });
                
                const piece = new THREE.Mesh(geometry, material);
                piece.castShadow = true;
                piece.receiveShadow = true;
                
                piece.userData = {
                    thickness: data.thickness,
                    width: data.width,
                    length: data.length,
                    isWoodPiece: true,
                    isActive: false
                };
                
                piece.position.fromArray(data.position);
                piece.rotation.fromArray(data.rotation);
                
                app.scene.add(piece);
            });
            
            saveCurrentProject();
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update any animations or dynamic elements here
            
            app.renderer.render(app.scene, app.camera);
        }
        
        // Initialize on load
        window.addEventListener('load', init);
        
        // Expose app functions to window for UI
        window.app = app;
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Wood Construction</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            user-select: none;
            background: #1a1a1a;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        #canvas.grabbing {
            cursor: grabbing;
        }
        
        /* Hamburger Menu Button */
        .menu-button {
            position: fixed;
            left: 20px;
            top: 20px;
            width: 40px;
            height: 40px;
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            z-index: 1001;
            transition: all 0.2s;
        }
        
        .menu-button:hover {
            background: rgba(60, 60, 60, 0.9);
        }
        
        .menu-button span {
            width: 24px;
            height: 2px;
            background: #fff;
            transition: all 0.3s;
        }
        
        .menu-button.active span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }
        
        .menu-button.active span:nth-child(2) {
            opacity: 0;
        }
        
        .menu-button.active span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }
        
        /* Side Panel */
        .side-panel {
            position: fixed;
            left: -350px;
            top: 0;
            background: rgba(40, 40, 40, 0.95);
            height: 100vh;
            width: 330px;
            padding: 80px 20px 20px;
            box-shadow: 2px 0 20px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
            transition: left 0.3s ease;
            z-index: 1000;
        }
        
        .side-panel.active {
            left: 0;
        }
        
        .panel-section {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel-section:last-child {
            border-bottom: none;
        }
        
        .panel-section h3 {
            font-size: 14px;
            margin-bottom: 15px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Material Selection */
        .thickness-group {
            margin-bottom: 20px;
        }
        
        .thickness-group h4 {
            font-size: 12px;
            color: #999;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .wood-option {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 6px 0;
            background: rgba(60, 60, 60, 0.6);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        
        .wood-option:hover {
            background: rgba(80, 80, 80, 0.6);
            transform: translateX(4px);
        }
        
        .wood-option.active {
            background: rgba(33, 150, 243, 0.2);
            border-color: #2196f3;
        }
        
        .wood-icon {
            width: 40px;
            height: 40px;
            margin-right: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            background: #2a2a2a;
        }
        
        .wood-label {
            font-size: 13px;
            font-weight: 500;
            color: #fff;
        }
        
        /* Project Management */
        .project-list {
            margin-bottom: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .project-item {
            padding: 8px 10px;
            margin: 4px 0;
            background: rgba(60, 60, 60, 0.6);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #fff;
            transition: all 0.2s;
        }
        
        .project-item:hover {
            background: rgba(80, 80, 80, 0.6);
        }
        
        .project-item.active {
            background: rgba(33, 150, 243, 0.2);
            font-weight: 500;
            border: 1px solid #2196f3;
        }
        
        .project-item button {
            padding: 2px 6px;
            font-size: 10px;
            background: #d32f2f;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .project-item button:hover {
            background: #b71c1c;
        }
        
        .project-controls button {
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .project-controls button:hover {
            background: #1976d2;
        }
        
        /* Overlay for closing menu */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 999;
            display: none;
        }
        
        .menu-overlay.active {
            display: block;
        }
        
        /* Hotkey Guide */
        .hotkey-guide {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 11px;
            transition: opacity 0.3s;
            max-width: 300px;
        }
        
        .hotkey-guide.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .hotkey-group {
            margin-bottom: 10px;
        }
        
        .hotkey-group h4 {
            font-size: 12px;
            margin-bottom: 5px;
            color: #4fc3f7;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .hotkey {
            display: flex;
            margin: 3px 0;
            color: #ccc;
        }
        
        .hotkey-key {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 8px;
            font-family: monospace;
            min-width: 20px;
            text-align: center;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Measurement Display */
        .measurement {
            position: fixed;
            background: rgba(33, 150, 243, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .measurement.hidden {
            opacity: 0;
        }
        
        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #999;
        }
        
        /* Status indicator */
        .status-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(33, 150, 243, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 100;
        }
        
        .status-indicator.hidden {
            opacity: 0;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading 3D environment...</div>
    <canvas id="canvas"></canvas>
    
    <div class="menu-button" id="menuButton" onclick="toggleMenu()">
        <span></span>
        <span></span>
        <span></span>
    </div>
    
    <div class="menu-overlay" id="menuOverlay" onclick="closeMenu()"></div>
    
    <div class="side-panel" id="sidePanel">
        <div class="panel-section">
            <h3>Projects</h3>
            <div class="project-list" id="projectList"></div>
            <div class="project-controls">
                <button onclick="app.createNewProject()">New Project</button>
                <button onclick="app.renameProject()">Rename</button>
            </div>
        </div>
        
        <div class="panel-section">
            <h3>Wood Materials</h3>
            <div id="materialList"></div>
        </div>
    </div>
    
    <div class="hotkey-guide" id="hotkeyGuide">
        <div class="hotkey-group" id="movementGuide" style="display: none;">
            <h4>Movement Mode Active</h4>
            <div class="hotkey"><span class="hotkey-key">Click + Drag</span> Move along axis</div>
            <div class="hotkey"><span class="hotkey-key">Release Key</span> Exit mode</div>
        </div>
        <div class="hotkey-group" id="selectedGuide" style="display: none;">
            <h4>Selected Pieces</h4>
            <div class="hotkey"><span class="hotkey-key">Z</span> Hold + drag for Z movement</div>
            <div class="hotkey"><span class="hotkey-key">X</span> Hold + drag for X movement</div>
            <div class="hotkey"><span class="hotkey-key">C</span> Hold + drag for Y movement</div>
            <div class="hotkey"><span class="hotkey-key">A</span> Rotate around Z</div>
            <div class="hotkey"><span class="hotkey-key">S</span> Rotate around X</div>
            <div class="hotkey"><span class="hotkey-key">D</span> Rotate around Y</div>
            <div class="hotkey"><span class="hotkey-key">E</span> + Click to duplicate</div>
            <div class="hotkey"><span class="hotkey-key">T</span> Delete selected</div>
            <div class="hotkey"><span class="hotkey-key">V</span> + Click end to adjust length</div>
        </div>
        <div class="hotkey-group" id="generalGuide">
            <h4>General</h4>
            <div class="hotkey"><span class="hotkey-key">Click</span> Select piece</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl + Click</span> Multi-select</div>
            <div class="hotkey"><span class="hotkey-key">Left Drag</span> Pan camera</div>
            <div class="hotkey"><span class="hotkey-key">Right Drag</span> Orbit camera</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl+Z</span> Undo</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl+Y</span> Redo</div>
            <div class="hotkey"><span class="hotkey-key">1-0</span> Quick material select</div>
        </div>
    </div>
    
    <div class="measurement hidden" id="measurement"></div>
    
    <div class="status-indicator hidden" id="statusIndicator"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global app object
        const app = {
            scene: null,
            camera: null,
            renderer: null,
            raycaster: new THREE.Raycaster(),
            mouse: new THREE.Vector2(),
            
            // State
            selectedPieces: new Set(),
            movementAxis: null,
            isDraggingPiece: false,
            dragStartPos: null, // World space intersection point where drag started
            initialPiecePositions: new Map(), // Stores original positions of pieces being dragged

            isLengthEditing: false,
            lengthEditPiece: null,
            lengthEditFace: null, // 'top' or 'bottom' for Z-axis ends, or could be extended
            lengthEditOriginalLength: 0,
            lengthEditOriginalPosition: null,
            lengthEditOriginalQuaternion: null,
            
            // Input state
            keys: {},
            mouseDown: false,
            rightMouseDown: false,
            lastMouseX: 0,
            lastMouseY: 0,
            
            // Camera state
            cameraDistance: 3,
            cameraTheta: Math.PI / 4, // Azimuthal angle (around Z-axis)
            cameraPhi: Math.PI / 3,   // Polar angle (from positive Z-axis)
            cameraTarget: new THREE.Vector3(0, 0, 0),
            
            // Wood dimensions (thickness x width in mm)
            woodDimensions: [
                { thickness: 20, widths: [48, 73, 98, 120] },
                { thickness: 28, widths: [48, 73, 98, 120] },
                { thickness: 36, widths: [48, 73, 98, 120] },
                { thickness: 48, widths: [48, 73, 98, 120] },
                { thickness: 98, widths: [48, 73, 98, 120] }
            ],
            
            selectedDimension: null,
            recentDimensions: [],
            
            // Project management
            projects: {},
            currentProject: null,
            
            // Undo/Redo
            undoStack: [],
            redoStack: [],
            
            // Visual helpers
            snapLines: [],
            measurementTimeout: null,
            measurementElement: null,
            statusTimeout: null
        };
        
        // Menu toggle functions
        function toggleMenu() {
            const panel = document.getElementById('sidePanel');
            const button = document.getElementById('menuButton');
            const overlay = document.getElementById('menuOverlay');
            
            panel.classList.toggle('active');
            button.classList.toggle('active');
            overlay.classList.toggle('active');
        }
        
        function closeMenu() {
            const panel = document.getElementById('sidePanel');
            const button = document.getElementById('menuButton');
            const overlay = document.getElementById('menuOverlay');
            
            panel.classList.remove('active');
            button.classList.remove('active');
            overlay.classList.remove('active');
        }
        
        // Show status message
        function showStatus(message) {
            const status = document.getElementById('statusIndicator');
            status.textContent = message;
            status.classList.remove('hidden');
            
            clearTimeout(app.statusTimeout);
            app.statusTimeout = setTimeout(() => {
                status.classList.add('hidden');
            }, 2000);
        }
        
        // Initialize the application
        function init() {
            // Setup Three.js
            app.scene = new THREE.Scene();
            app.scene.background = new THREE.Color(0x1a1a1a);
            app.scene.fog = new THREE.Fog(0x1a1a1a, 10, 50);
            
            // Camera setup (Z is up)
            app.camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            updateCameraPosition(); // Initial position
            
            // Renderer
            const canvas = document.getElementById('canvas');
            app.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            app.renderer.setSize(window.innerWidth, window.innerHeight);
            app.renderer.shadowMap.enabled = true;
            app.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            app.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, -5, 10); // Adjusted Y for better angle
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            app.scene.add(directionalLight);
            
            // Ground plane (solid gray)
            const groundGeometry = new THREE.BoxGeometry(40, 40, 0.1);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a4a4a,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.position.z = -0.05; // Center of the ground box is at z=-0.05, so top surface is at z=0
            ground.receiveShadow = true;
            ground.userData.isGround = true;
            app.scene.add(ground);
            
            // Add subtle grid on top of ground
            const gridHelper = new THREE.GridHelper(40, 80, 0x555555, 0x3a3a3a);
            gridHelper.rotation.x = Math.PI / 2;
            gridHelper.position.z = 0.001; // Slightly above the ground surface
            app.scene.add(gridHelper);
            
            // Initialize UI
            initializeMaterialPanel();
            loadProjects();
            
            // Create measurement element
            app.measurementElement = document.getElementById('measurement');
            
            // Event listeners
            setupEventListeners();
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Start render loop
            animate();
        }
        
        // Update camera position based on spherical coordinates
        function updateCameraPosition() {
            // Phi: polar angle (from positive Z-axis). 0 = top, PI = bottom.
            // Theta: azimuthal angle (in XY plane, from positive X-axis).
            app.camera.position.x = app.cameraTarget.x + app.cameraDistance * Math.sin(app.cameraPhi) * Math.cos(app.cameraTheta);
            app.camera.position.y = app.cameraTarget.y + app.cameraDistance * Math.sin(app.cameraPhi) * Math.sin(app.cameraTheta);
            app.camera.position.z = app.cameraTarget.z + app.cameraDistance * Math.cos(app.cameraPhi);
            
            app.camera.up.set(0, 0, 1); // Ensure Z is up for horizon lock
            app.camera.lookAt(app.cameraTarget);
        }
        
        // Initialize material selection panel
        function initializeMaterialPanel() {
            const materialList = document.getElementById('materialList');
            
            app.woodDimensions.forEach((group, groupIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'thickness-group';
                
                const groupTitle = document.createElement('h4');
                groupTitle.textContent = `${group.thickness}mm Thickness`;
                groupDiv.appendChild(groupTitle);
                
                group.widths.forEach((width, widthIndex) => {
                    const option = document.createElement('div');
                    option.className = 'wood-option';
                    option.dataset.thickness = group.thickness;
                    option.dataset.width = width;
                    
                    const icon = document.createElement('canvas');
                    icon.className = 'wood-icon';
                    icon.width = 40;
                    icon.height = 40;
                    const ctx = icon.getContext('2d');
                    
                    const scale = 0.3; 
                    const t = group.thickness * scale;
                    const w = width * scale;
                    
                    ctx.fillStyle = '#8B6F47';
                    ctx.fillRect(
                        (40 - t) / 2,
                        (40 - w) / 2,
                        t,
                        w
                    );
                    
                    ctx.strokeStyle = '#6B5637';
                    ctx.strokeRect(
                        (40 - t) / 2,
                        (40 - w) / 2,
                        t,
                        w
                    );
                    
                    const label = document.createElement('div');
                    label.className = 'wood-label';
                    label.textContent = `${group.thickness}×${width}mm`;
                    
                    option.appendChild(icon);
                    option.appendChild(label);
                    
                    option.addEventListener('click', () => {
                        selectWoodDimension(group.thickness, width);
                        closeMenu();
                    });
                    
                    groupDiv.appendChild(option);
                });
                
                materialList.appendChild(groupDiv);
            });
        }
        
        // Select wood dimension
        function selectWoodDimension(thickness, width) {
            document.querySelectorAll('.wood-option').forEach(opt => {
                opt.classList.remove('active');
            });
            
            const selected = document.querySelector(
                `.wood-option[data-thickness="${thickness}"][data-width="${width}"]`
            );
            if (selected) {
                selected.classList.add('active');
            }
            
            app.selectedDimension = { thickness, width };
            
            const key = `${thickness}x${width}`;
            app.recentDimensions = app.recentDimensions.filter(d => d !== key);
            app.recentDimensions.unshift(key);
            if (app.recentDimensions.length > 10) {
                app.recentDimensions.pop();
            }
            
            createWoodPiece(thickness, width);
        }
        
        // Create wood piece
        function createWoodPiece(thickness, width, length = 500) {
            const t = thickness / 1000; // depth (X)
            const w = width / 1000;   // width (Y)
            const l = length / 1000;  // height (Z, length of wood)
            
            const geometry = new THREE.BoxGeometry(t, w, l);
            const material = new THREE.MeshStandardMaterial({
                color: 0x8B6F47,
                roughness: 0.7,
                metalness: 0.1
            });
            
            const piece = new THREE.Mesh(geometry, material);
            piece.castShadow = true;
            piece.receiveShadow = true;
            
            piece.userData = {
                thickness, // Store original mm dimensions
                width,
                length,
                isWoodPiece: true
            };
            
            // Position on the floor at camera target, ensuring it's above ground
            const halfLength = l / 2;
            piece.position.set(
                app.cameraTarget.x,
                app.cameraTarget.y,
                Math.max(halfLength, 0) // Ensure bottom is at or above Z=0
            );
            
            app.scene.add(piece);
            
            clearSelection();
            app.selectedPieces.add(piece);
            updatePieceSelection(piece, true);
            
            saveState();
            saveCurrentProject();
            
            updateHotkeyGuide();
            showStatus(`Created ${thickness}×${width}mm piece`);
        }
        
        // Setup event listeners
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('contextmenu', e => e.preventDefault());
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('wheel', onMouseWheel);
        }
        
        function onWindowResize() {
            app.camera.aspect = window.innerWidth / window.innerHeight;
            app.camera.updateProjectionMatrix();
            app.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onMouseDown(event) {
            if (event.target.id !== 'canvas') return;
            
            if (event.button === 0) { // Left mouse button
                app.mouseDown = true;
                updateMouse(event);
                
                app.raycaster.setFromCamera(app.mouse, app.camera);
                const objects = app.scene.children.filter(obj => obj.userData.isWoodPiece);
                const intersects = app.raycaster.intersectObjects(objects);
                
                if (intersects.length > 0) {
                    const clickedPiece = intersects[0].object;
                    const intersectionPoint = intersects[0].point;
                    
                    if (app.keys['v'] && app.selectedPieces.has(clickedPiece)) {
                        // Length editing mode
                        const face = intersects[0].face;
                        const normal = face.normal.clone();
                        // Transform normal to world space
                        normal.transformDirection(clickedPiece.matrixWorld); 
                        
                        // Determine if clicked face is an "end" face (along local Z axis of the piece)
                        // This assumes BoxGeometry is (thickness, width, length) -> (X, Y, Z)
                        const localNormal = face.normal.clone(); // Normal in piece's local space
                        
                        if (Math.abs(localNormal.z) > 0.9) { // Clicked one of the Z-faces (ends)
                            app.isLengthEditing = true;
                            app.lengthEditPiece = clickedPiece;
                            // 'top' for +Z face, 'bottom' for -Z face in local coords
                            app.lengthEditFace = localNormal.z > 0 ? 'top' : 'bottom'; 
                            app.lengthEditOriginalLength = clickedPiece.userData.length;
                            app.lengthEditOriginalPosition = clickedPiece.position.clone();
                            app.lengthEditOriginalQuaternion = clickedPiece.quaternion.clone();
                            app.lastMouseX = event.clientX; // Reset for length editing delta
                            app.lastMouseY = event.clientY;
                            showStatus('Length edit mode. Drag mouse.');
                        } else {
                            showStatus('Click an end-face (along length) to adjust length with V.');
                        }
                    } else if (app.keys['e']) {
                        duplicatePiece(clickedPiece);
                    } else if (app.movementAxis && app.selectedPieces.has(clickedPiece)) {
                        app.isDraggingPiece = true;
                        app.dragStartPos = intersectionPoint.clone(); // World space point
                        app.initialPiecePositions.clear();
                        app.selectedPieces.forEach(p => {
                            app.initialPiecePositions.set(p, p.position.clone());
                        });
                    } else {
                        // Selection
                        if (event.ctrlKey) {
                            if (app.selectedPieces.has(clickedPiece)) {
                                app.selectedPieces.delete(clickedPiece);
                                updatePieceSelection(clickedPiece, false);
                            } else {
                                app.selectedPieces.add(clickedPiece);
                                updatePieceSelection(clickedPiece, true);
                            }
                        } else {
                            if (!app.selectedPieces.has(clickedPiece)) {
                                clearSelection();
                                app.selectedPieces.add(clickedPiece);
                                updatePieceSelection(clickedPiece, true);
                            }
                            // If already selected and not dragging, allow starting drag
                            app.isDraggingPiece = true; // Allow dragging selected piece without axis key
                            app.dragStartPos = intersectionPoint.clone();
                            app.initialPiecePositions.clear();
                            app.selectedPieces.forEach(p => {
                                app.initialPiecePositions.set(p, p.position.clone());
                            });

                        }
                        updateHotkeyGuide();
                    }
                } else if (!event.ctrlKey && !app.movementAxis) {
                    clearSelection();
                    updateHotkeyGuide();
                }
                
            } else if (event.button === 2) { // Right mouse button
                app.rightMouseDown = true;
            }
            
            app.lastMouseX = event.clientX;
            app.lastMouseY = event.clientY;
            document.getElementById('canvas').classList.add('grabbing');
        }
        
        function onMouseMove(event) {
            const deltaX = event.clientX - app.lastMouseX;
            const deltaY = event.clientY - app.lastMouseY;
            
            updateMouse(event); // Keep mouse coords updated for raycasting

            if (app.isDraggingPiece) {
                 if (app.movementAxis) {
                    moveSelectedAlongAxis(event); // Pass full event for consistency if needed
                 } else if (app.selectedPieces.size > 0 && app.mouseDown) {
                    // Free drag if no axis key is pressed but dragging started on a piece
                    // This is a bit more complex, involves projecting mouse movement onto a plane.
                    // For now, let's require axis keys for explicit movement.
                    // Or, if drag started on a piece, initiate a planar drag (e.g., on XY plane at piece height)
                    // This part is not explicitly requested to change, so keeping simple.
                 }
            } else if (app.isLengthEditing) {
                adjustLength(event);
            } else if (app.mouseDown && !app.movementAxis) { // Left mouse drag - Panning
                const panSpeed = 0.003 * app.cameraDistance / 3; // Scale pan speed with zoom
                const right = new THREE.Vector3();
                const up = new THREE.Vector3(); // Use camera's local up for panning relative to view

                app.camera.getWorldDirection(new THREE.Vector3()); // Ensure matrixWorld is updated
                right.copy(app.camera.right).multiplyScalar(-deltaX * panSpeed);
                up.copy(app.camera.up).multiplyScalar(deltaY * panSpeed);
                
                app.cameraTarget.add(right).add(up);
                updateCameraPosition();
                
            } else if (app.rightMouseDown) { // Right mouse drag - Orbiting
                const orbitSpeed = 0.005;
                app.cameraTheta -= deltaX * orbitSpeed; // Azimuthal angle
                app.cameraPhi -= deltaY * orbitSpeed;   // Polar angle
                
                // Clamp phi to prevent looking straight up/down or flipping over
                app.cameraPhi = Math.max(0.01, Math.min(Math.PI - 0.01, app.cameraPhi));
                
                updateCameraPosition();
            }
            
            app.lastMouseX = event.clientX;
            app.lastMouseY = event.clientY;
        }
        
        function onMouseUp(event) {
            if (event.button === 0) { // Left mouse
                app.mouseDown = false;
                
                if (app.isDraggingPiece || app.isLengthEditing) {
                    saveState();
                    saveCurrentProject();
                }
                
                // If dragging piece without an axis key, and it was just a click for selection, don't clear drag state
                if (!app.movementAxis && app.isDraggingPiece) {
                    // Check if it was a short drag (click) or actual drag
                    // For simplicity, always reset if not in axis mode
                }

                app.isDraggingPiece = false;
                // app.dragStartPos = null; // Keep for potential snapping on release if needed later
                app.initialPiecePositions.clear();

                if (app.isLengthEditing) { // Finalize length editing
                    if (app.lengthEditPiece && app.lengthEditPiece.userData.length < 10) {
                         // This case should be handled by min length in adjustLength
                         // If it somehow results in <10mm, consider deleting or reverting
                        showStatus(`Piece length too small (${app.lengthEditPiece.userData.length}mm), reverting may be needed.`);
                    }
                    app.isLengthEditing = false;
                    app.lengthEditPiece = null;
                    app.lengthEditFace = null;
                }
                
            } else if (event.button === 2) { // Right mouse
                app.rightMouseDown = false;
            }
            
            document.getElementById('canvas').classList.remove('grabbing');
            clearSnapLines();
            hideMeasurement();
        }
        
        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            app.keys[key] = true;
            
            if (app.selectedPieces.size > 0 && !event.repeat) {
                let newAxis = null;
                if (key === 'z') newAxis = 'z';
                else if (key === 'x') newAxis = 'x';
                else if (key === 'c') newAxis = 'y'; // 'c' for Y-axis

                if (newAxis) {
                    app.movementAxis = newAxis;
                    updateSnapLines();
                    showStatus(`${newAxis.toUpperCase()}-axis movement mode`);
                    updateHotkeyGuide();
                    // If mouse is already down on a selected piece, start dragging immediately
                    if (app.mouseDown && app.selectedPieces.size > 0) {
                        let pieceUnderMouse = false;
                        app.raycaster.setFromCamera(app.mouse, app.camera);
                        const intersects = app.raycaster.intersectObjects(Array.from(app.selectedPieces));
                        if (intersects.length > 0) {
                             app.isDraggingPiece = true;
                             app.dragStartPos = intersects[0].point.clone();
                             app.initialPiecePositions.clear();
                             app.selectedPieces.forEach(p => {
                                 app.initialPiecePositions.set(p, p.position.clone());
                             });
                        }
                    }
                }
                
                if (key === 'a') rotateSelected('z');
                else if (key === 's') rotateSelected('x');
                else if (key === 'd') rotateSelected('y');
            }
            
            if (key === 't' && app.selectedPieces.size > 0) {
                deleteSelectedPieces();
            }
            
            if (event.ctrlKey) {
                if (key === 'z') { event.preventDefault(); undo(); }
                else if (key === 'y') { event.preventDefault(); redo(); }
            }
            
            const numKey = parseInt(event.key);
            if (!isNaN(numKey) && numKey >= 0 && numKey <= 9) {
                const index = numKey === 0 ? 9 : numKey - 1;
                if (app.recentDimensions[index]) {
                    const [thickness, width] = app.recentDimensions[index].split('x').map(Number);
                    selectWoodDimension(thickness, width);
                }
            }
        }
        
        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            delete app.keys[key];
            
            if ((key === 'z' && app.movementAxis === 'z') ||
                (key === 'x' && app.movementAxis === 'x') ||
                (key === 'c' && app.movementAxis === 'y')) {
                
                if (app.isDraggingPiece) { // If actively dragging when axis key is released
                    saveState();
                    saveCurrentProject();
                }
                app.movementAxis = null;
                app.isDraggingPiece = false; // Stop dragging when axis key is released
                clearSnapLines();
                hideMeasurement();
                updateHotkeyGuide();
            }
        }
        
        function onMouseWheel(event) {
            const zoomSpeed = 0.1; // Adjusted for more intuitive zoom
            app.cameraDistance *= (1 + event.deltaY * -zoomSpeed * 0.01); // Multiplicative zoom
            app.cameraDistance = Math.max(0.5, Math.min(20, app.cameraDistance));
            updateCameraPosition();
        }
        
        function updateMouse(event) {
            app.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            app.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function moveSelectedAlongAxis(event) {
            if (!app.movementAxis || app.selectedPieces.size === 0 || !app.dragStartPos || !app.isDraggingPiece) return;

            app.raycaster.setFromCamera(app.mouse, app.camera);
            
            // Create a plane for dragging based on the initial drag point and camera view
            const planeNormal = new THREE.Vector3();
            app.camera.getWorldDirection(planeNormal); // Normal to the screen
            const dragPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(planeNormal, app.dragStartPos);
            
            const intersectPoint = new THREE.Vector3();
            app.raycaster.ray.intersectPlane(dragPlane, intersectPoint);

            if (intersectPoint) {
                const worldDelta = intersectPoint.clone().sub(app.dragStartPos);
                
                let finalMovement = new THREE.Vector3();
                finalMovement[app.movementAxis] = worldDelta[app.movementAxis];

                // --- Floor Collision and Snap to Floor (for Z-axis movement) ---
                if (app.movementAxis === 'z') {
                    let minRequiredZCorrection = 0; // How much upward correction is needed to prevent going below floor
                    let currentLowestProjectedZ = Infinity;

                    app.selectedPieces.forEach(piece => {
                        const initialPos = app.initialPiecePositions.get(piece);
                        if (!initialPos) return;

                        const pieceBox = new THREE.Box3().setFromObject(piece); // Get current bounding box
                        // To get the correct min Z, we need to consider the piece's geometry relative to its origin
                        // The Box3 from object already accounts for this.
                        // We need the min Z of the piece if it were at its *original* drag start position + finalMovement
                        const originalPieceBox = new THREE.Box3();
                        originalPieceBox.copy(piece.geometry.boundingBox).applyMatrix4(piece.matrixWorld);
                        // This is complex if pieces are rotated. Simpler: use initialPiecePositions.
                        // The pieceBox.min.z is world min Z.
                        // The piece's height is piece.geometry.parameters.depth (if Z is length)
                        
                        // Calculate the piece's bounding box if it were at its initial drag position
                        const tempMatrix = new THREE.Matrix4().compose(initialPos, piece.quaternion, piece.scale);
                        const checkBox = piece.geometry.boundingBox.clone().applyMatrix4(tempMatrix);

                        const lowestZAfterMove = checkBox.min.z + finalMovement.z;
                        
                        if (lowestZAfterMove < 0) {
                            minRequiredZCorrection = Math.max(minRequiredZCorrection, -lowestZAfterMove);
                        }
                        currentLowestProjectedZ = Math.min(currentLowestProjectedZ, lowestZAfterMove);
                    });

                    if (minRequiredZCorrection > 0) {
                        finalMovement.z += minRequiredZCorrection;
                        currentLowestProjectedZ += minRequiredZCorrection; // Update after correction
                    }

                    // Snap to floor if very close
                    const snapToFloorThreshold = 0.01; // 10mm
                    if (Math.abs(currentLowestProjectedZ) < snapToFloorThreshold && currentLowestProjectedZ !== 0) {
                        finalMovement.z -= currentLowestProjectedZ; // Adjust to make lowest Z exactly 0
                    }
                }
                // --- End Floor Collision and Snap ---
                
                // (Future: Integrate general snapping here, it might adjust finalMovement)
                // const snapInfo = checkSnapForMovement(finalMovement);
                // if (snapInfo.snapDelta) {
                //    finalMovement.add(snapInfo.snapDelta);
                // }

                app.selectedPieces.forEach(piece => {
                    const initialPos = app.initialPiecePositions.get(piece);
                    if (initialPos) {
                        piece.position.copy(initialPos).add(finalMovement);
                    }
                });

                // Show measurement (e.g., distance moved, or distance to snap target)
                // For now, let's show the magnitude of movement along the axis
                const movedDistance = Math.abs(finalMovement[app.movementAxis]);
                if (movedDistance > 0.001) { // If there's noticeable movement
                    showMeasurement(movedDistance * 1000); // Show in mm
                    // Position measurement near the center of the selection
                    const selectionCenter = new THREE.Vector3();
                    app.selectedPieces.forEach(p => selectionCenter.add(p.position));
                    selectionCenter.divideScalar(app.selectedPieces.size);
                    updateMeasurementPosition(selectionCenter);
                }
            }
        }
        
        function checkSnapForMovement(movement) {
            // This function is complex and needs careful implementation for general snapping.
            // For now, it's a placeholder. Floor snapping is handled in moveSelectedAlongAxis.
            const snapThreshold = 0.01; // 10mm
            let minDistance = Infinity;
            let snapDelta = null;
            let measurementPos = null;
            
            // Example: Snap to grid (not implemented here)
            // Example: Snap to other pieces (partially in old code, needs review)

            return {
                snapDelta,
                distance: minDistance === Infinity ? null : minDistance,
                measurementPos
            };
        }
        
        function rotateSelected(axis) {
            if (app.selectedPieces.size === 0) return;
            
            const center = new THREE.Vector3();
            app.selectedPieces.forEach(piece => {
                center.add(piece.position);
            });
            center.divideScalar(app.selectedPieces.size);
            
            const rotation = Math.PI / 2; // 90 degrees
            const axisVector = new THREE.Vector3();
            if (axis === 'x') axisVector.set(1, 0, 0);
            else if (axis === 'y') axisVector.set(0, 1, 0);
            else if (axis === 'z') axisVector.set(0, 0, 1);
            else return;

            app.selectedPieces.forEach(piece => {
                // Rotate piece around its own center
                piece.rotateOnWorldAxis(axisVector, rotation); // Simpler for world axis rotation

                // If multiple pieces, rotate position around group center
                if (app.selectedPieces.size > 1) {
                    const offset = piece.position.clone().sub(center);
                    offset.applyAxisAngle(axisVector, rotation);
                    piece.position.copy(center).add(offset);
                }
                 // Ensure piece is not below floor after rotation
                const pieceBox = new THREE.Box3().setFromObject(piece);
                if (pieceBox.min.z < 0) {
                    piece.position.z += -pieceBox.min.z;
                }
            });
            
            saveState();
            saveCurrentProject();
            showStatus(`Rotated around ${axis.toUpperCase()} axis`);
        }
        
        function getBoxCorners(box) {
            // (Existing function - can be kept if used by full snapping logic)
            return [ /* ... corners ... */ ];
        }
        
        function updateSnapLines() {
            clearSnapLines();
            if (!app.movementAxis || app.selectedPieces.size === 0) return;
            // (Existing function - can be kept or enhanced)
        }
        
        function clearSnapLines() {
            app.snapLines.forEach(line => app.scene.remove(line));
            app.snapLines = [];
        }
        
        function adjustLength(event) {
            if (!app.lengthEditPiece || !app.isLengthEditing) return;

            const piece = app.lengthEditPiece;
            // Original state was stored in onMouseDown when editing started
            const originalLengthMM = app.lengthEditOriginalLength;
            const originalPosition = app.lengthEditOriginalPosition; // World position
            const originalQuaternion = app.lengthEditOriginalQuaternion;

            // Use mouse delta from the start of length editing for more intuitive control
            const mouseDeltaMM = (event.clientX - app.lastMouseX) * 10; // Sensitivity for length change in mm

            let lengthChangeDueToMouseMM;
            if (app.lengthEditFace === 'top') { // 'top' is +localZ end
                lengthChangeDueToMouseMM = mouseDeltaMM;
            } else { // 'bottom' is -localZ end
                lengthChangeDueToMouseMM = -mouseDeltaMM; 
            }
            
            let newLengthMM = originalLengthMM + lengthChangeDueToMouseMM;
            newLengthMM = Math.max(10, newLengthMM); // Min length 10mm
            const snappedNewLengthMM = Math.round(newLengthMM / 10) * 10;

            const actualTotalLengthChangeMM = snappedNewLengthMM - originalLengthMM;

            // Update geometry: BoxGeometry is (X, Y, Z) -> (thickness, width, length)
            const t_meters = piece.userData.thickness / 1000;
            const w_meters = piece.userData.width / 1000;
            const l_new_meters = snappedNewLengthMM / 1000;

            // Avoid unnecessary geometry recreation if length hasn't effectively changed
            if (Math.abs(snappedNewLengthMM - piece.userData.length) < 0.1 && piece.geometry.parameters.depth === l_new_meters) {
                 showMeasurement(`Length: ${piece.userData.length}mm`);
                 const currentEditedFaceCenterLocal = new THREE.Vector3(0,0, (app.lengthEditFace === 'top' ? 1 : -1) * piece.geometry.parameters.depth/2 );
                 updateMeasurementPosition(piece.localToWorld(currentEditedFaceCenterLocal.clone()));
                return;
            }
            
            piece.geometry.dispose();
            piece.geometry = new THREE.BoxGeometry(t_meters, w_meters, l_new_meters);
            piece.userData.length = snappedNewLengthMM;

            // Adjust piece's world position to keep the non-edited end fixed.
            // The piece's origin is its center. When length changes, both ends shift relative to the old center.
            // We need to shift the piece by half of the *total* length change, along its local Z-axis.
            const shiftDistanceMeters = (actualTotalLengthChangeMM / 2000.0); // Half the total change, in meters

            // Determine the direction of shift in local Z.
            // If 'top' face (+localZ) was clicked/edited, it moved. The bottom (-localZ) was fixed.
            // If length increased (actualTotalLengthChangeMM > 0), center moved in +localZ by shiftDistanceMeters.
            // To keep bottom fixed, the entire piece must also move in +localZ by shiftDistanceMeters.
            let localShiftAxis = new THREE.Vector3(0, 0, 0);
            if (app.lengthEditFace === 'top') {
                localShiftAxis.set(0, 0, 1); // Shift in positive local Z
            } else { // 'bottom' face (-localZ) was edited, top fixed.
                localShiftAxis.set(0, 0, -1); // Shift in negative local Z
            }
            
            const worldShiftVector = localShiftAxis.clone()
                .multiplyScalar(shiftDistanceMeters)
                .applyQuaternion(originalQuaternion); // Apply original orientation to the shift vector
            
            // Set position based on original position + calculated shift
            piece.position.copy(originalPosition).add(worldShiftVector);
            
            // Ensure piece is not below floor after length adjustment and repositioning
            const pieceBox = new THREE.Box3().setFromObject(piece);
            if (pieceBox.min.z < 0) {
                piece.position.z += -pieceBox.min.z;
            }

            piece.material.color.setHex(0x8B6F47); // Reset color

            showMeasurement(`Length: ${snappedNewLengthMM}mm`);
            const editedFaceCenterLocal = new THREE.Vector3(0,0, (app.lengthEditFace === 'top' ? 1 : -1) * l_new_meters/2 );
            updateMeasurementPosition(piece.localToWorld(editedFaceCenterLocal.clone()));
        }

        function duplicatePiece(original) {
            const clone = original.clone(); // This clones geometry and material by reference initially
            clone.material = original.material.clone(); // Deep clone material
            clone.userData = { ...original.userData }; // Copy user data
            
            clone.position.add(new THREE.Vector3(0.1, 0.1, 0.1)); // Offset slightly
             // Ensure duplicated piece is not below floor
            const pieceBox = new THREE.Box3().setFromObject(clone);
            if (pieceBox.min.z < 0) {
                clone.position.z += -pieceBox.min.z;
            }

            app.scene.add(clone);
            
            clearSelection();
            app.selectedPieces.add(clone);
            updatePieceSelection(clone, true);
            
            saveState();
            saveCurrentProject();
            updateHotkeyGuide();
            showStatus('Duplicated piece');
        }
        
        function deleteSelectedPieces() {
            if (app.selectedPieces.size === 0) return;
            saveState(); 
            
            app.selectedPieces.forEach(piece => {
                app.scene.remove(piece);
                // Make sure to dispose geometry and material if they are unique to this piece
                if (piece.geometry) piece.geometry.dispose();
                if (piece.material) piece.material.dispose();
            });
            
            const count = app.selectedPieces.size;
            app.selectedPieces.clear();
            saveCurrentProject();
            updateHotkeyGuide();
            showStatus(`Deleted ${count} piece${count > 1 ? 's' : ''}`);
        }
        
        function clearSelection() {
            app.selectedPieces.forEach(piece => updatePieceSelection(piece, false));
            app.selectedPieces.clear();
        }
        
        function updatePieceSelection(piece, selected) {
            if (selected) {
                piece.material.emissive = new THREE.Color(0xcc3333); // Brighter red for selection
                piece.material.emissiveIntensity = 0.3;
            } else {
                piece.material.emissive = new THREE.Color(0x000000);
                piece.material.emissiveIntensity = 0;
            }
        }
        
        function showMeasurement(text) {
            const measurement = app.measurementElement;
            measurement.textContent = typeof text === 'number' ? `${Math.round(text)}mm` : text;
            measurement.classList.remove('hidden');
            
            clearTimeout(app.measurementTimeout);
            app.measurementTimeout = setTimeout(() => {
                measurement.classList.add('hidden');
            }, 2000);
        }
        
        function hideMeasurement() {
            app.measurementElement.classList.add('hidden');
            clearTimeout(app.measurementTimeout);
        }
        
        function updateMeasurementPosition(worldPosition) {
            if (!worldPosition) return;
            
            const screenPosition = worldPosition.clone().project(app.camera);
            const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;
            
            app.measurementElement.style.left = `${x}px`;
            app.measurementElement.style.top = `${y}px`;
            app.measurementElement.style.transform = 'translate(-50%, -150%)'; // Position above the point
        }
        
        function updateHotkeyGuide() {
            const movementGuide = document.getElementById('movementGuide');
            const selectedGuide = document.getElementById('selectedGuide');
            
            movementGuide.style.display = app.movementAxis ? 'block' : 'none';
            selectedGuide.style.display = !app.movementAxis && app.selectedPieces.size > 0 ? 'block' : 'none';
        }
        
        // Project management (using localStorage, simple alert/prompt)
        function loadProjects() {
            const saved = localStorage.getItem('woodProjects');
            if (saved) {
                app.projects = JSON.parse(saved);
            } else {
                app.projects = { 'Project 1': { pieces: [] } };
            }
            const projectNames = Object.keys(app.projects);
            if (projectNames.length > 0) {
                loadProject(projectNames[0]);
            }
            updateProjectList();
        }
        
        function saveCurrentProject() {
            if (!app.currentProject) return;
            const pieces = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece) {
                    pieces.push({
                        thickness: obj.userData.thickness,
                        width: obj.userData.width,
                        length: obj.userData.length,
                        position: obj.position.toArray(),
                        rotation: [obj.quaternion.x, obj.quaternion.y, obj.quaternion.z, obj.quaternion.w] // Save quaternion
                    });
                }
            });
            app.projects[app.currentProject] = { pieces };
            localStorage.setItem('woodProjects', JSON.stringify(app.projects));
        }
        
        function loadProject(name) {
            const toRemove = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece) toRemove.push(obj);
            });
            toRemove.forEach(obj => {
                app.scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            clearSelection();
            
            const project = app.projects[name];
            if (project && project.pieces) {
                project.pieces.forEach(data => {
                    const t = data.thickness / 1000;
                    const w = data.width / 1000;
                    const l = data.length / 1000;
                    const geometry = new THREE.BoxGeometry(t, w, l);
                    geometry.computeBoundingBox(); // Important for accurate Box3 later
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x8B6F47, roughness: 0.7, metalness: 0.1
                    });
                    const piece = new THREE.Mesh(geometry, material);
                    piece.castShadow = true;
                    piece.receiveShadow = true;
                    piece.userData = {
                        thickness: data.thickness, width: data.width, length: data.length, isWoodPiece: true
                    };
                    piece.position.fromArray(data.position);
                    piece.quaternion.fromArray(data.rotation); // Load quaternion
                    app.scene.add(piece);
                });
            }
            app.currentProject = name;
            updateProjectList();
            showStatus(`Loaded ${name}`);
            app.undoStack = []; // Clear undo/redo for new project
            app.redoStack = [];
            saveState(); // Save initial state of loaded project for undo
        }
        
        function updateProjectList() {
            const projectList = document.getElementById('projectList');
            projectList.innerHTML = '';
            Object.keys(app.projects).forEach(name => {
                const item = document.createElement('div');
                item.className = 'project-item';
                if (name === app.currentProject) item.classList.add('active');
                const nameSpan = document.createElement('span');
                nameSpan.textContent = name;
                nameSpan.style.cursor = 'pointer';
                nameSpan.onclick = () => { loadProject(name); closeMenu(); };
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = (e) => { e.stopPropagation(); deleteProject(name); };
                item.appendChild(nameSpan);
                item.appendChild(deleteBtn);
                projectList.appendChild(item);
            });
        }
        
        app.createNewProject = function() { // Expose to window via app object
            const name = prompt('Project name:', `Project ${Object.keys(app.projects).length + 1}`);
            if (name && !app.projects[name]) {
                app.projects[name] = { pieces: [] };
                // saveCurrentProject(); // No need, loadProject will save its (empty) state
                loadProject(name); // This will clear scene and save the new empty project
            } else if (name && app.projects[name]) {
                alert("A project with this name already exists.");
            }
        }
        
        app.renameProject = function() { // Expose to window
            if (!app.currentProject) return;
            const newName = prompt('New name:', app.currentProject);
            if (newName && newName !== app.currentProject && !app.projects[newName]) {
                app.projects[newName] = app.projects[app.currentProject];
                delete app.projects[app.currentProject];
                app.currentProject = newName;
                localStorage.setItem('woodProjects', JSON.stringify(app.projects));
                updateProjectList();
                showStatus(`Renamed to ${newName}`);
            } else if (newName && app.projects[newName] && newName !== app.currentProject) {
                 alert("A project with this name already exists.");
            }
        }
        
        function deleteProject(name) {
            if (Object.keys(app.projects).length <= 1) {
                alert('Cannot delete the last project'); return;
            }
            if (confirm(`Delete project "${name}"? This cannot be undone.`)) {
                delete app.projects[name];
                if (name === app.currentProject) {
                    const remaining = Object.keys(app.projects);
                    loadProject(remaining[0]); // Load the first remaining project
                }
                localStorage.setItem('woodProjects', JSON.stringify(app.projects));
                updateProjectList();
                showStatus(`Deleted project ${name}`);
            }
        }
        
        // Undo/Redo
        function saveState() {
            const state = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece) {
                    state.push({
                        thickness: obj.userData.thickness, width: obj.userData.width, length: obj.userData.length,
                        position: obj.position.toArray(),
                        rotation: [obj.quaternion.x, obj.quaternion.y, obj.quaternion.z, obj.quaternion.w]
                    });
                }
            });
            app.undoStack.push(state);
            app.redoStack = [];
            if (app.undoStack.length > 50) app.undoStack.shift();
        }
        
        function undo() {
            if (app.undoStack.length <= 1) { // Keep at least one state (initial) or disallow undo if only 1 state
                 showStatus('Nothing to undo'); return;
            }
            const currentStateJson = JSON.stringify(app.undoStack.pop()); // Current state is removed
            app.redoStack.push(JSON.parse(currentStateJson)); // Add it to redo

            const previousState = JSON.parse(JSON.stringify(app.undoStack[app.undoStack.length - 1])); // Peek
            restoreState(previousState);
            showStatus('Undo');
        }
        
        function redo() {
            if (app.redoStack.length === 0) { showStatus('Nothing to redo'); return; }
            const nextState = app.redoStack.pop();
            app.undoStack.push(nextState); // Add it back to undo stack
            restoreState(JSON.parse(JSON.stringify(nextState))); // Restore a copy
            showStatus('Redo');
        }
        
        function restoreState(state) {
            const toRemove = [];
            app.scene.traverse((obj) => { if (obj.userData.isWoodPiece) toRemove.push(obj); });
            toRemove.forEach(obj => {
                app.scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            clearSelection();
            
            state.forEach(data => {
                const t = data.thickness / 1000; const w = data.width / 1000; const l = data.length / 1000;
                const geometry = new THREE.BoxGeometry(t, w, l);
                geometry.computeBoundingBox();
                const material = new THREE.MeshStandardMaterial({ color: 0x8B6F47, roughness: 0.7, metalness: 0.1 });
                const piece = new THREE.Mesh(geometry, material);
                piece.castShadow = true; piece.receiveShadow = true;
                piece.userData = { thickness: data.thickness, width: data.width, length: data.length, isWoodPiece: true };
                piece.position.fromArray(data.position);
                piece.quaternion.fromArray(data.rotation);
                app.scene.add(piece);
            });
            saveCurrentProject(); // Save this restored state to localStorage for the current project
            updateHotkeyGuide();
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            app.renderer.render(app.scene, app.camera);
        }
        
        window.addEventListener('load', init);
        window.app = app; // Expose main app object for UI calls from HTML
    </script>
</body>
</html>

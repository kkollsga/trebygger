<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Wood Construction (Grid-Based Snapping)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; overflow: hidden; user-select: none; background: #1a1a1a; }
        #canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; cursor: grab; }
        #canvas.grabbing { cursor: grabbing; }
        .menu-button { position: fixed; left: 20px; top: 20px; width: 40px; height: 40px; background: rgba(40, 40, 40, 0.9); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; cursor: pointer; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 4px; z-index: 1001; transition: all 0.2s; }
        .menu-button:hover { background: rgba(60, 60, 60, 0.9); }
        .menu-button span { width: 24px; height: 2px; background: #fff; transition: all 0.3s; }
        .menu-button.active span:nth-child(1) { transform: rotate(45deg) translate(5px, 5px); }
        .menu-button.active span:nth-child(2) { opacity: 0; }
        .menu-button.active span:nth-child(3) { transform: rotate(-45deg) translate(5px, -5px); }

        .side-panel { position: fixed; left: -350px; top: 0; background: rgba(40, 40, 40, 0.95); height: 100vh; width: 330px; padding: 20px; box-shadow: 2px 0 20px rgba(0, 0, 0, 0.5); overflow-y: auto; transition: left 0.3s ease; z-index: 1000; }
        .side-panel.active { left: 0; }
        .side-panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .side-panel-title { margin-left: 50px; font-size: 16px; font-weight: 600; color: #fff; text-transform: uppercase; letter-spacing: 1px; }
        .settings-button { background: rgba(60, 60, 60, 0.6); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; color: #ccc; }
        .settings-button:hover { background: rgba(80, 80, 80, 0.7); color: #fff; }
        .settings-button.active { background: rgba(33, 150, 243, 0.3); border-color: #2196f3; color: #4fc3f7; }
        .settings-panel { max-height: 0; overflow: hidden; transition: max-height 0.3s ease, margin-bottom 0.3s ease; margin-bottom: 0; background: rgba(50, 50, 50, 0.4); border-radius: 8px; }
        .settings-panel.expanded { max-height: 300px; margin-bottom: 20px; }
        .settings-panel-inner { padding: 15px; }
        .settings-panel h3 { font-size: 12px; color: #4fc3f7; margin-bottom: 15px; text-transform: uppercase; letter-spacing: 0.5px; display: flex; align-items: center; gap: 8px; }

        .panel-section { margin-bottom: 30px; padding-bottom: 20px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .panel-section:last-child { border-bottom: none; }
        .panel-section h3 { font-size: 14px; margin-bottom: 15px; color: #fff; text-transform: uppercase; letter-spacing: 1px; display: flex; justify-content: space-between; align-items: center; }
        .panel-section h3 .add-project-btn { background: none; border: none; color: #4fc3f7; font-size: 16px; cursor: pointer; padding: 0 5px; }
        .panel-section h3 .add-project-btn:hover { color: #fff; }

        .thickness-group { margin-bottom: 10px; background: rgba(50, 50, 50, 0.5); border-radius: 8px; overflow: hidden; }
        .thickness-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; background: rgba(60, 60, 60, 0.6); cursor: pointer; transition: background 0.2s; }
        .thickness-header:hover { background: rgba(70, 70, 70, 0.6); }
        .thickness-header h4 { font-size: 12px; color: #fff; margin: 0; text-transform: uppercase; letter-spacing: 0.5px; }
        .collapse-icon { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; transition: transform 0.3s; }
        .collapse-icon::before { content: '▼'; color: #999; font-size: 10px; }
        .thickness-group.collapsed .collapse-icon { transform: rotate(-90deg); }
        .width-options { display: flex; gap: 6px; padding: 8px; max-height: 200px; overflow: hidden; transition: max-height 0.3s ease, padding 0.3s ease; }
        .thickness-group.collapsed .width-options { max-height: 0; padding: 0 8px; }

        .wood-option { display: flex; flex-direction: column; align-items: center; padding: 6px 4px; background: rgba(60, 60, 60, 0.6); border-radius: 6px; cursor: pointer; transition: all 0.2s; border: 2px solid transparent; flex: 1; min-width: 0; }
        .wood-option:hover { background: rgba(80, 80, 80, 0.6); transform: translateY(-2px); }
        .wood-option.active { background: rgba(33, 150, 243, 0.2); border-color: #2196f3; }
        .wood-icon { width: 100%; max-width: 60px; height: 20px; margin-bottom: 4px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 3px; background: #2a2a2a; }
        .wood-label { font-size: 9px; font-weight: 500; color: #fff; text-align: center; line-height: 1.2; }

        .project-list { margin-bottom: 10px; max-height: 200px; overflow-y: auto; }
        .project-item { padding: 8px 10px; margin: 4px 0; background: rgba(60, 60, 60, 0.6); border-radius: 6px; cursor: default; font-size: 12px; display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; color: #fff; transition: background-color 0.2s; position: relative; }
        .project-item:hover { background: rgba(75, 75, 75, 0.7); }
        .project-item:hover .project-actions { opacity: 1; }
        .project-item.active { background: rgba(33, 150, 243, 0.2); font-weight: 500; border: 1px solid #2196f3; }
        .project-name { flex-grow: 1; cursor: pointer; padding: 2px 4px; margin-right: 5px; }
        .project-actions { display: flex; align-items: center; opacity: 0; transition: opacity 0.2s ease-in-out; }
        .project-actions button { background: none; border: none; color: #bbb; cursor: pointer; padding: 3px 5px; font-size: 11px; margin-left: 3px; border-radius: 3px; }
        .project-actions button:hover { color: #fff; background-color: rgba(255,255,255,0.1); }
        .project-delete-confirm { display: none; width: 100%; background-color: rgba(80, 80, 80, 0.85); padding: 8px; margin-top: 6px; border-radius: 4px; text-align: center; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        .project-delete-confirm.visible { display: block; }
        .project-delete-confirm span { font-size: 11px; margin-right: 10px; color: #eee; }
        .project-delete-confirm button { background: none; border: none; color: white; font-size: 14px; cursor: pointer; padding: 3px 6px; border-radius: 4px; transition: background-color 0.2s; }
        .project-delete-confirm .confirm-yes { color: #4CAF50; }
        .project-delete-confirm .confirm-yes:hover { background-color: rgba(76, 175, 80, 0.2); }
        .project-delete-confirm .confirm-no { color: #f44336; }
        .project-delete-confirm .confirm-no:hover { background-color: rgba(244, 67, 54, 0.2); }
        .project-edit-form, .new-project-input-item { width: 100%; display: flex; align-items: center; padding: 5px 0; }
        .project-edit-form input[type="text"], .new-project-input-item input[type="text"] { flex-grow: 1; background: rgba(20,20,20,0.9); border: 1px solid #555; color: white; padding: 6px 8px; border-radius: 4px; font-size: 12px; margin-right: 5px; }
        .project-edit-form input[type="text"]:focus, .new-project-input-item input[type="text"]:focus { border-color: #2196f3; outline: none; }
        .project-edit-form button, .new-project-input-item button { background: none; border: 1px solid #555; color: #ccc; font-size: 13px; cursor: pointer; padding: 5px 7px; border-radius: 4px; margin-left: 3px; transition: all 0.2s; }
        .project-edit-form button:hover, .new-project-input-item button:hover { background-color: rgba(255,255,255,0.1); color: #fff; }
        .project-edit-form .confirm-edit-project, .new-project-input-item .confirm-new-project { border-color: #4CAF50; color: #4CAF50; }
        .project-edit-form .confirm-edit-project:hover, .new-project-input-item .confirm-new-project:hover { background-color: rgba(76, 175, 80, 0.2); color: #66bb6a; }
        .project-edit-form .cancel-edit-project, .new-project-input-item .cancel-new-project { border-color: #f44336; color: #f44336; }
        .project-edit-form .cancel-edit-project:hover, .new-project-input-item .cancel-new-project:hover { background-color: rgba(244, 67, 54, 0.2); color: #ef5350; }
    
        .settings-item { display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.08); }
        .settings-item:last-child { border-bottom: none; }
        .settings-label { color: #fff; font-size: 12px; font-weight: 500; }
        .toggle-switch { position: relative; width: 44px; height: 24px; background: rgba(255, 255, 255, 0.2); border-radius: 12px; cursor: pointer; transition: background 0.3s; }
        .toggle-switch.active { background: #2196f3; }
        .toggle-switch::after { content: ''; position: absolute; width: 20px; height: 20px; background: white; border-radius: 50%; top: 2px; left: 2px; transition: transform 0.3s; }
        .toggle-switch.active::after { transform: translateX(20px); }

        .menu-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: transparent; z-index: 999; display: none; }
        .info-panel { position: fixed; bottom: 20px; left: 20px; background: rgba(40, 40, 40, 0.95); border: 1px solid rgba(255, 255, 255, 0.1); color: white; padding: 15px; border-radius: 12px; font-size: 12px; min-width: 250px; transition: opacity 0.3s; z-index: 100; }
        .info-panel.hidden { opacity: 0; pointer-events: none; }
        .info-panel h4 { font-size: 13px; margin-bottom: 10px; color: #4fc3f7; text-transform: uppercase; letter-spacing: 0.5px; }
        .info-row { display: flex; justify-content: space-between; margin: 5px 0; color: #ccc; }
        .info-label { color: #fff; font-weight: 500; }
        .info-value { color: #4fc3f7; font-weight: 600; }

        .collision-warning { background: rgba(255, 87, 34, 0.2); border: 1px solid #ff5722; color: #ff5722; padding: 8px; border-radius: 6px; margin-top: 10px; font-size: 11px; }

        .project-details { background: rgba(50,50,50,0.6); border-radius: 8px; padding: 15px; margin-top: 10px; }
        .project-details h4 { font-size: 12px; color: #4fc3f7; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }

        .detail-row { display: flex; justify-content: space-between; margin: 6px 0; font-size: 11px; color: #ccc; }
        .detail-label { color: #fff; }
        .detail-value { color: #4fc3f7; font-weight: 600; }

        .materials-breakdown { margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); }
        .material-item { display: flex; justify-content: space-between; margin: 4px 0; font-size: 10px; color: #999; }
        .hotkey-guide { position: fixed; bottom: 20px; right: 20px; background: rgba(40, 40, 40, 0.9); border: 1px solid rgba(255, 255, 255, 0.1); color: white; padding: 15px; border-radius: 12px; font-size: 11px; transition: opacity 0.3s; max-width: 300px; z-index: 100; }
        .hotkey-guide.hidden { opacity: 0; pointer-events: none; }
        .hotkey-group { margin-bottom: 10px; }
        .hotkey-group h4 { font-size: 12px; margin-bottom: 5px; color: #4fc3f7; text-transform: uppercase; letter-spacing: 0.5px; }
        .hotkey { display: flex; margin: 3px 0; color: #ccc; }
        .hotkey-key { background: rgba(255, 255, 255, 0.1); padding: 2px 6px; border-radius: 4px; margin-right: 8px; font-family: monospace; min-width: 20px; text-align: center; color: #fff; border: 1px solid rgba(255,255,255,0.2); }

        .measurement { position: fixed; background: rgba(33, 150, 243, 0.9); color: white; padding: 6px 12px; border-radius: 6px; font-size: 13px; font-weight: 600; pointer-events: none; transition: opacity 0.2s; z-index: 1000; box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
        .measurement.hidden { opacity: 0; }
        .measurement.typing { background: rgba(76, 175, 80, 0.9); }
        .measurement-input { background: transparent; border: none; color: white; font-weight: 600; font-size: 13px; outline: none; width: 80px; text-align: center; }

        .loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 18px; color: #999; }
        .status-indicator { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(33, 150, 243, 0.9); color: white; padding: 8px 16px; border-radius: 20px; font-size: 12px; font-weight: 600; pointer-events: none; transition: opacity 0.3s, background-color 0.3s; z-index: 1002; }
        .status-indicator.hidden { opacity: 0; }

        .snap-indicator { position: fixed; background: rgba(76, 175, 80, 0.9); color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; pointer-events: none; transition: opacity 0.2s; z-index: 1001; }
        .snap-indicator.hidden { opacity: 0; }
        
        .snap-preview { pointer-events: none; }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading 3D environment...</div>
    <canvas id="canvas"></canvas>
    
    <div class="menu-button" id="menuButton" onclick="toggleMenu()">
        <span></span>
        <span></span>
        <span></span>
    </div>
    
    <div class="menu-overlay" id="menuOverlay" onclick="closeMenu()"></div>
    
    <div class="side-panel" id="sidePanel">
        <div class="side-panel-header">
            <div class="side-panel-title">Workshop</div>
            <button class="settings-button" id="settingsButton" onclick="toggleSettingsSection()" title="Settings">
                <i class="fas fa-cog"></i>
            </button>
        </div>
        
        <div class="settings-panel" id="settingsContent">
            <div class="settings-panel-inner">
                <h3><i class="fas fa-cog"></i> Settings</h3>
                <div class="settings-item">
                    <span class="settings-label">Grid Snap (G)</span>
                    <div class="toggle-switch active" id="gridToggle" onclick="app.toggleGridSnap()"></div>
                </div>
                <div class="settings-item">
                    <span class="settings-label">Hotkey Guide</span>
                    <div class="toggle-switch" id="hotkeyToggle" onclick="app.toggleHotkeyGuide()"></div>
                </div>
            </div>
        </div>
        <div class="panel-section">
            <h3>
                <span>Projects</span>
                <button class="add-project-btn" onclick="app.gui.promptNewProject()" title="New Project">
                    <i class="fas fa-plus"></i>
                </button>
            </h3>
            <div class="project-list" id="projectList"></div>
            </div>
        
        <div class="panel-section">
            <h3>Wood Materials</h3>
            <div id="materialList"></div>
        </div>
        
        <div class="panel-section">
            <h3>Project Details</h3>
            <div class="project-details" id="projectDetailsContent">
                 <div class="detail-row">
                    <span class="detail-label">Total Cost:</span>
                    <span class="detail-value" id="totalCost">0 kr</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Total Weight:</span>
                    <span class="detail-value" id="totalWeight">0 kg</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Total Pieces:</span>
                    <span class="detail-value" id="totalPieces">0</span>
                </div>
                <div class="materials-breakdown">
                    <h4>Materials Used</h4>
                    <div id="materialsBreakdown"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="info-panel hidden" id="infoPanel">
        <h4>Selection Info</h4>
        <div id="infoContent"></div>
    </div>
    
    <div class="hotkey-guide" id="hotkeyGuide">
        <div class="hotkey-group" id="movementGuide" style="display: none;">
            <h4>Movement Mode Active</h4>
            <div class="hotkey"><span class="hotkey-key">Click + Drag</span> Move along axis</div>
            <div class="hotkey"><span class="hotkey-key">Type Number</span> Exact distance</div>
            <div class="hotkey"><span class="hotkey-key">↑/↓</span> Move ±10mm</div>
            <div class="hotkey"><span class="hotkey-key">Enter</span> Confirm typed value</div>
            <div class="hotkey"><span class="hotkey-key">Release Key</span> Exit mode</div>
        </div>
        <div class="hotkey-group" id="lengthEditGuide" style="display: none;">
            <h4>Length Edit Mode</h4>
            <div class="hotkey"><span class="hotkey-key">Drag</span> Adjust length</div>
            <div class="hotkey"><span class="hotkey-key">Type Number</span> Exact length</div>
            <div class="hotkey"><span class="hotkey-key">↑/↓</span> Adjust ±10mm</div>
            <div class="hotkey"><span class="hotkey-key">Enter</span> Confirm typed value</div>
        </div>
        <div class="hotkey-group" id="selectedGuide" style="display: none;">
            <h4>Selected Pieces</h4>
            <div class="hotkey"><span class="hotkey-key">Z</span> Hold + ↑/↓ for Z movement</div>
            <div class="hotkey"><span class="hotkey-key">X</span> Hold + ↑/↓ for X movement</div>
            <div class="hotkey"><span class="hotkey-key">C</span> Hold + ↑/↓ for Y movement</div>
            <div class="hotkey"><span class="hotkey-key">A</span> Rotate around Local Z</div>
            <div class="hotkey"><span class="hotkey-key">S</span> Rotate around Local X</div>
            <div class="hotkey"><span class="hotkey-key">D</span> Rotate around Local Y</div>
            <div class="hotkey"><span class="hotkey-key">E</span> + Click to duplicate</div>
            <div class="hotkey"><span class="hotkey-key">T</span> Delete selected</div>
            <div class="hotkey"><span class="hotkey-key">V</span> + Click end to adjust length</div>
        </div>
        <div class="hotkey-group" id="generalGuide">
            <h4>General</h4>
            <div class="hotkey"><span class="hotkey-key">Click</span> Select piece</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl + Click</span> Multi-select</div>
            <div class="hotkey"><span class="hotkey-key">Left Drag</span> Pan camera</div>
            <div class="hotkey"><span class="hotkey-key">Right Drag</span> Orbit camera</div>
            <div class="hotkey"><span class="hotkey-key">Wheel</span> Zoom camera</div>
            <div class="hotkey"><span class="hotkey-key">+ / -</span> Zoom in/out</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl+Z</span> Undo</div>
            <div class="hotkey"><span class="hotkey-key">Ctrl+Y</span> Redo</div>
            <div class="hotkey"><span class="hotkey-key">G</span> Toggle grid snap</div>
            <div class="hotkey"><span class="hotkey-key">1-0</span> Quick material select</div>
        </div>
    </div>
    
    <div class="measurement hidden" id="measurement"></div>
    <div class="snap-indicator hidden" id="snapIndicator"></div>
    <div class="status-indicator hidden" id="statusIndicator"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Constants
        const GRID_SIZE = 10; // 10mm grid - all positions will snap to multiples of this
        const FLOAT_PRECISION = 0.0001; // 0.1mm - floating point precision tolerance
        const MIN_PIECE_LENGTH = 0.010; // 10mm minimum length

        // Grid-Based Collision and Snapping System
        class GridSnapSystem {
            static GRID_SIZE = GRID_SIZE / 1000; // Convert to meters
            static FACE_SNAP_THRESHOLD = 0.020; // 20mm threshold for face snapping
            
            // Snap a value to the grid
            static snapToGrid(value) {
                return Math.round(value / this.GRID_SIZE) * this.GRID_SIZE;
            }
            
            // Snap a vector to the grid
            static snapVectorToGrid(vector) {
                return new THREE.Vector3(
                    this.snapToGrid(vector.x),
                    this.snapToGrid(vector.y),
                    this.snapToGrid(vector.z)
                );
            }
            
            // Get aligned bounds for a piece (bounds that align to grid)
            static getAlignedBounds(piece) {
                // Get the mesh from the piece group
                const mesh = piece.userData.isWoodPiece ? piece.getObjectByName('mesh') : piece;
                if (!mesh || !piece.userData) { // Ensure piece.userData exists
                    console.warn("getAlignedBounds: Mesh or userData not found for piece", piece);
                    return new THREE.Box3(); // Return empty bounds if essential data is missing
                }

                const { thickness, width } = piece.userData;

                // --- MODIFICATION START ---
                // Use currentPreviewLength if available (during length editing),
                // otherwise use the stored/final length.
                const currentLength = (piece.userData.currentPreviewLength !== undefined)
                                    ? piece.userData.currentPreviewLength
                                    : piece.userData.length;
                // --- MODIFICATION END ---

                const t = thickness / 1000; // Convert mm to meters
                const w = width / 1000;   // Convert mm to meters
                const l = currentLength / 1000; // Convert mm to meters, using the resolved current length

                // Create bounds in local space
                const halfT = t / 2;
                const halfW = w / 2;
                const halfL = l / 2;

                const corners = [
                    new THREE.Vector3(-halfT, -halfW, -halfL),
                    new THREE.Vector3(halfT, -halfW, -halfL),
                    new THREE.Vector3(-halfT, halfW, -halfL),
                    new THREE.Vector3(halfT, halfW, -halfL),
                    new THREE.Vector3(-halfT, -halfW, halfL),
                    new THREE.Vector3(halfT, -halfW, halfL),
                    new THREE.Vector3(-halfT, halfW, halfL),
                    new THREE.Vector3(halfT, halfW, halfL)
                ];

                // Transform to world space
                // Ensure the piece's matrixWorld is up-to-date before this call if it might have changed.
                // (The calling function, applyLengthChange, does call piece.updateMatrixWorld(true) before this)
                const worldCorners = corners.map(corner =>
                    corner.clone().applyMatrix4(piece.matrixWorld)
                );

                return new THREE.Box3().setFromPoints(worldCorners);
            }
            
            // Check if two bounds overlap (for collision detection)
            static boundsOverlap(bounds1, bounds2) {
                const tolerance = FLOAT_PRECISION; // 0.1mm
                
                // Check for actual overlap (pieces penetrating each other)
                // Touching exactly (same face positions) should NOT be considered overlap
                const xOverlap = bounds1.max.x > bounds2.min.x + tolerance && 
                                bounds1.min.x < bounds2.max.x - tolerance;
                const yOverlap = bounds1.max.y > bounds2.min.y + tolerance && 
                                bounds1.min.y < bounds2.max.y - tolerance;
                const zOverlap = bounds1.max.z > bounds2.min.z + tolerance && 
                                bounds1.min.z < bounds2.max.z - tolerance;
                
                return xOverlap && yOverlap && zOverlap;
            }
            
            // Find face-to-face snaps (the primary snapping mechanism)
            static findFaceSnaps(movingBounds, staticBounds) {
                const snaps = [];
                const threshold = this.FACE_SNAP_THRESHOLD;
                
                // Check all 6 face pairs
                const faceTests = [
                    { axis: 'x', movingFace: 'min', staticFace: 'max' },
                    { axis: 'x', movingFace: 'max', staticFace: 'min' },
                    { axis: 'y', movingFace: 'min', staticFace: 'max' },
                    { axis: 'y', movingFace: 'max', staticFace: 'min' },
                    { axis: 'z', movingFace: 'min', staticFace: 'max' },
                    { axis: 'z', movingFace: 'max', staticFace: 'min' }
                ];
                
                for (const test of faceTests) {
                    const movingFacePos = movingBounds[test.movingFace][test.axis];
                    const staticFacePos = staticBounds[test.staticFace][test.axis];
                    const distance = Math.abs(movingFacePos - staticFacePos);
                    
                    if (distance < threshold) {
                        // Check if faces have overlapping area on other axes
                        const axes = ['x', 'y', 'z'];
                        const otherAxes = axes.filter(a => a !== test.axis);
                        let hasOverlapArea = true;
                        
                        for (const axis of otherAxes) {
                            const overlap = Math.min(movingBounds.max[axis], staticBounds.max[axis]) - 
                                           Math.max(movingBounds.min[axis], staticBounds.min[axis]);
                            if (overlap <= FLOAT_PRECISION) {
                                hasOverlapArea = false;
                                break;
                            }
                        }
                        
                        if (hasOverlapArea) {
                            const snapOffset = staticFacePos - movingFacePos;
                            snaps.push({
                                axis: test.axis,
                                offset: snapOffset,
                                distance: distance,
                                priority: 1 // Face snaps have highest priority
                            });
                        }
                    }
                }
                
                return snaps;
            }
            
            // Apply snapping to a movement
            // Fixed version that preserves face snaps and doesn't re-grid-snap them
            static applySnapping(pieces, movement, startPositions) {
            if (pieces.size === 0) return movement;

            let snappedMovement = movement.clone();

            // Find face snaps for all moving pieces
            const staticPieces = app.scene.children.filter(
                obj => obj.userData.isWoodPiece && !pieces.has(obj)
            );

            let bestSnap = null;
            let bestSnapDistance = this.FACE_SNAP_THRESHOLD;

            // Check each moving piece for potential snaps
            pieces.forEach(movingPiece => {
                const startPos = startPositions.get(movingPiece);
                if (!startPos) return;
                
                // Create temporary piece at current movement position (don't grid-snap yet for face detection)
                const tempPiece = movingPiece.clone();
                tempPiece.position.copy(startPos).add(snappedMovement);
                tempPiece.updateMatrixWorld(true);
                
                const movingBounds = this.getAlignedBounds(tempPiece);
                
                // Check against all static pieces
                staticPieces.forEach(staticPiece => {
                    staticPiece.updateMatrixWorld(true);
                    const staticBounds = this.getAlignedBounds(staticPiece);
                    
                    const snaps = this.findFaceSnaps(movingBounds, staticBounds);
                    
                    // Find the best snap (shortest distance)
                    snaps.forEach(snap => {
                        if (snap.distance < bestSnapDistance) {
                            bestSnap = snap;
                            bestSnapDistance = snap.distance;
                        }
                    });
                });
            });

            // Apply the best snap found - this creates perfect face-to-face contact
            if (bestSnap) {
                snappedMovement[bestSnap.axis] += bestSnap.offset;
                
                // DON'T re-snap to grid after face snapping - preserve the perfect contact
                showSnapIndicator('Face snap');
                
                // Check floor constraint after face snap
                let needsFloorSnap = false;
                pieces.forEach(piece => {
                    const startPos = startPositions.get(piece);
                    if (!startPos) return;
                    
                    const tempPiece = piece.clone();
                    tempPiece.position.copy(startPos).add(snappedMovement);
                    tempPiece.updateMatrixWorld(true);
                    
                    const bounds = this.getAlignedBounds(tempPiece);
                    if (bounds.min.z < -FLOAT_PRECISION) {
                        const floorCorrection = -bounds.min.z;
                        snappedMovement.z += floorCorrection;
                        needsFloorSnap = true;
                    }
                });
                
                if (needsFloorSnap) {
                    // Only snap Z to grid, preserve X,Y face contact
                    snappedMovement.z = this.snapToGrid(snappedMovement.z);
                }
                
                return snappedMovement;
            }

            // No face snap found, apply grid snapping
            snappedMovement = this.snapVectorToGrid(snappedMovement);

            // Check floor constraint
            let needsFloorSnap = false;
            pieces.forEach(piece => {
                const startPos = startPositions.get(piece);
                if (!startPos) return;
                
                const tempPiece = piece.clone();
                tempPiece.position.copy(startPos).add(snappedMovement);
                tempPiece.updateMatrixWorld(true);
                
                const bounds = this.getAlignedBounds(tempPiece);
                if (bounds.min.z < -FLOAT_PRECISION) {
                    const floorCorrection = -bounds.min.z;
                    snappedMovement.z += floorCorrection;
                    needsFloorSnap = true;
                }
            });

            if (needsFloorSnap) {
                snappedMovement = this.snapVectorToGrid(snappedMovement);
                showSnapIndicator('Floor snap');
            }

            return snappedMovement;
            }
            
            // Check for collisions
            static checkCollisions(pieces, movement, startPositions) {
                if (pieces.size === 0) return false;
                
                const staticPieces = app.scene.children.filter(
                    obj => obj.userData.isWoodPiece && !pieces.has(obj)
                );
                
                // Check each moving piece
                for (const movingPiece of pieces) {
                    const startPos = startPositions.get(movingPiece);
                    if (!startPos) continue;
                    
                    const tempPiece = movingPiece.clone();
                    tempPiece.position.copy(startPos).add(movement);
                    tempPiece.updateMatrixWorld(true);
                    
                    const movingBounds = this.getAlignedBounds(tempPiece);
                    
                    // Check against static pieces
                    for (const staticPiece of staticPieces) {
                        staticPiece.updateMatrixWorld(true);
                        const staticBounds = this.getAlignedBounds(staticPiece);
                        
                        if (this.boundsOverlap(movingBounds, staticBounds)) {
                            return true;
                        }
                    }
                    
                    // Check against other moving pieces
                    for (const otherMovingPiece of pieces) {
                        if (otherMovingPiece === movingPiece) continue;
                        
                        const otherStartPos = startPositions.get(otherMovingPiece);
                        if (!otherStartPos) continue;
                        
                        const otherTempPiece = otherMovingPiece.clone();
                        otherTempPiece.position.copy(otherStartPos).add(movement);
                        otherTempPiece.updateMatrixWorld(true);
                        
                        const otherBounds = this.getAlignedBounds(otherTempPiece);
                        
                        if (this.boundsOverlap(movingBounds, otherBounds)) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            // Find a safe position for a new piece
            static findSafePosition(piece, preferredPosition, excludePieces = new Set()) {
                const allPieces = app.scene.children.filter(obj => 
                    obj.userData.isWoodPiece && obj !== piece && !excludePieces.has(obj)
                );
                
                // Start with grid-snapped preferred position
                piece.position.copy(this.snapVectorToGrid(preferredPosition));
                piece.updateMatrixWorld(true);
                
                // Try to snap to existing pieces first
                let snapped = false;
                const pieceBounds = this.getAlignedBounds(piece);
                
                for (const existingPiece of allPieces) {
                    existingPiece.updateMatrixWorld(true);
                    const existingBounds = this.getAlignedBounds(existingPiece);
                    
                    const snaps = this.findFaceSnaps(pieceBounds, existingBounds);
                    if (snaps.length > 0) {
                        // Apply the first valid snap
                        const snap = snaps[0];
                        piece.position[snap.axis] += snap.offset;
                        piece.position.copy(this.snapVectorToGrid(piece.position));
                        piece.updateMatrixWorld(true);
                        
                        // Check if this position is collision-free
                        const newBounds = this.getAlignedBounds(piece);
                        let hasCollision = false;
                        
                        for (const otherPiece of allPieces) {
                            if (otherPiece === existingPiece) continue;
                            otherPiece.updateMatrixWorld(true);
                            const otherBounds = this.getAlignedBounds(otherPiece);
                            
                            if (this.boundsOverlap(newBounds, otherBounds)) {
                                hasCollision = true;
                                break;
                            }
                        }
                        
                        if (!hasCollision) {
                            snapped = true;
                            break;
                        }
                    }
                }
                
                // If snapping didn't work, find an empty grid position
                if (!snapped) {
                    const gridStep = this.GRID_SIZE;
                    const maxAttempts = 50;
                    
                    for (let attempt = 0; attempt < maxAttempts; attempt++) {
                        const pieceBounds = this.getAlignedBounds(piece);
                        let hasCollision = false;
                        
                        for (const otherPiece of allPieces) {
                            otherPiece.updateMatrixWorld(true);
                            const otherBounds = this.getAlignedBounds(otherPiece);
                            
                            if (this.boundsOverlap(pieceBounds, otherBounds)) {
                                hasCollision = true;
                                break;
                            }
                        }
                        
                        if (!hasCollision) break;
                        
                        // Try next position in expanding spiral
                        const angle = (attempt * 0.5) * Math.PI;
                        const radius = gridStep * (1 + Math.floor(attempt / 8));
                        piece.position.x = this.snapToGrid(preferredPosition.x + Math.cos(angle) * radius);
                        piece.position.y = this.snapToGrid(preferredPosition.y + Math.sin(angle) * radius);
                        piece.updateMatrixWorld(true);
                    }
                }
                
                // Ensure piece is on or above floor
                const finalBounds = this.getAlignedBounds(piece);
                if (finalBounds.min.z < 0) {
                    piece.position.z -= finalBounds.min.z;
                    piece.position.z = this.snapToGrid(piece.position.z);
                }
                
                return true;
            }
            
            // Check scene for any collisions
            static checkSceneCollisions(excludePieces = new Set()) {
                const pieces = app.scene.children.filter(obj => 
                    obj.userData.isWoodPiece && !excludePieces.has(obj)
                );
                
                const collisions = new Set();
                
                for (let i = 0; i < pieces.length; i++) {
                    for (let j = i + 1; j < pieces.length; j++) {
                        const piece1 = pieces[i];
                        const piece2 = pieces[j];
                        
                        piece1.updateMatrixWorld(true);
                        piece2.updateMatrixWorld(true);
                        
                        const bounds1 = this.getAlignedBounds(piece1);
                        const bounds2 = this.getAlignedBounds(piece2);
                        
                        if (this.boundsOverlap(bounds1, bounds2)) {
                            collisions.add(piece1);
                            collisions.add(piece2);
                        }
                    }
                }
                
                return collisions;
            }
            // New helper function to find maximum movement distance without collision
            static findMaxMovementWithoutCollision(pieces, desiredMovement, startPositions) {
                if (pieces.size === 0 || desiredMovement.lengthSq() < 0.000001) {
                    return desiredMovement;
                }
                
                const staticPieces = app.scene.children.filter(
                    obj => obj.userData.isWoodPiece && !pieces.has(obj)
                );
                
                // Binary search for maximum movement distance
                let minScale = 0;
                let maxScale = 1;
                let bestScale = 0;
                const iterations = 20; // Precision iterations
                
                for (let i = 0; i < iterations; i++) {
                    const testScale = (minScale + maxScale) / 2;
                    const testMovement = desiredMovement.clone().multiplyScalar(testScale);
                    
                    let hasCollision = false;
                    
                    // Test all moving pieces at this movement scale
                    for (const movingPiece of pieces) {
                        const startPos = startPositions.get(movingPiece);
                        if (!startPos) continue;
                        
                        const tempPiece = movingPiece.clone();
                        tempPiece.position.copy(startPos).add(testMovement);
                        tempPiece.updateMatrixWorld(true);
                        
                        const movingBounds = this.getAlignedBounds(tempPiece);
                        
                        // Check against static pieces
                        for (const staticPiece of staticPieces) {
                            staticPiece.updateMatrixWorld(true);
                            const staticBounds = this.getAlignedBounds(staticPiece);
                            
                            if (this.boundsOverlap(movingBounds, staticBounds)) {
                                hasCollision = true;
                                break;
                            }
                        }
                        
                        if (hasCollision) break;
                        
                        // Check against other moving pieces
                        for (const otherMovingPiece of pieces) {
                            if (otherMovingPiece === movingPiece) continue;
                            
                            const otherStartPos = startPositions.get(otherMovingPiece);
                            if (!otherStartPos) continue;
                            
                            const otherTempPiece = otherMovingPiece.clone();
                            otherTempPiece.position.copy(otherStartPos).add(testMovement);
                            otherTempPiece.updateMatrixWorld(true);
                            
                            const otherBounds = this.getAlignedBounds(otherTempPiece);
                            
                            if (this.boundsOverlap(movingBounds, otherBounds)) {
                                hasCollision = true;
                                break;
                            }
                        }
                        
                        if (hasCollision) break;
                    }
                    
                    if (hasCollision) {
                        maxScale = testScale;
                    } else {
                        bestScale = testScale;
                        minScale = testScale;
                    }
                }
                
                return desiredMovement.clone().multiplyScalar(bestScale);
            }
        }

        // Global app object
        const app = {
            scene: null,
            camera: null,
            renderer: null,
            raycaster: new THREE.Raycaster(),
            mouse: new THREE.Vector2(),
            
            // State
            selectedPieces: new Set(),
            
            // Movement state - unified system
            movementState: {
                active: false,
                mode: null, // 'drag', 'typed', 'step'
                axis: null, // 'x', 'y', 'z', 'free'
                startPositions: new Map(),
                currentOffset: new THREE.Vector3(),
                constraints: new Set(),
                typedValue: '',
                isDragging: false,
                lengthEditData: null,
                // Reference plane data for stable free movement
                referencePlane: null,
                referenceCenter: null,
                initialIntersection: null,
                // Track collision state during movement
                hasCollisions: false
            },
            
            // Visual helpers - removed selectionOutlines and resizeIndicators since they're integrated
            snapGhosts: new Map(),
            
            // Input state
            keys: {},
            mouseDown: false, 
            rightMouseDown: false, 
            lastMouseX: 0,
            lastMouseY: 0,
            
            // Grid snap
            gridSize: GRID_SIZE, 
            gridSnapEnabled: true,
            hotkeyGuideEnabled: true,
            settingsPanelExpanded: false,
            
            // UI State
            collapsedThicknesses: new Set(),
            isAddingProject: false, 
            editingProjectName: null, 
            
            // Activity tracking for auto-hide
            lastActivity: Date.now(),
            activityTimeout: null,
            
            // Camera state
            cameraDistance: 3,
            cameraTheta: Math.PI / 4,
            cameraPhi: Math.PI / 3,
            cameraTarget: new THREE.Vector3(0, 0, 0),
            
            // Wood dimensions and properties
            woodDimensions: [
                { thickness: 20, widths: [48, 73, 98, 120] },
                { thickness: 28, widths: [48, 73, 98, 120] },
                { thickness: 36, widths: [48, 73, 98, 120] },
                { thickness: 48, widths: [48, 73, 98, 120, 148, 198] },
                { thickness: 98, widths: [48, 73, 98, 120] }
            ],
            woodDensity: 0.559, 
            selectedDimension: null,
            recentDimensions: [],
            
            // Project management
            projects: {},
            currentProject: null,
            
            // Undo/Redo
            undoStack: [],
            redoStack: [],
            
            // Visual helpers
            guideLines: [],
            measurementTimeout: null,
            measurementElement: null,
            statusTimeout: null,
            
            gui: {} 
        };

        // --- UNIFIED MOVEMENT SYSTEM ---
        
        class MovementConstraint {
            constructor(name) {
                this.name = name;
            }
            
            apply(pieces, movement, startPositions, mode) {
                // Override in subclasses
                return movement;
            }
        }
        
        class FloorConstraint extends MovementConstraint {
            constructor() {
                super('floor');
            }
            
            apply(pieces, movement, startPositions, mode) {
                let constrainedMovement = movement.clone();
                let minZCorrection = 0;
                
                pieces.forEach(piece => {
                    const startPos = startPositions.get(piece);
                    if (!startPos) return;
                    
                    const tempPiece = piece.clone();
                    tempPiece.position.copy(startPos).add(constrainedMovement);
                    tempPiece.updateMatrixWorld(true);
                    
                    const bounds = GridSnapSystem.getAlignedBounds(tempPiece);
                    if (bounds.min.z < 0) {
                        minZCorrection = Math.max(minZCorrection, -bounds.min.z);
                    }
                });
                
                if (minZCorrection > 0) {
                    constrainedMovement.z += minZCorrection;
                }
                
                return constrainedMovement;
            }
        }
        
        class CollisionConstraint extends MovementConstraint {
            constructor() {
                super('collision');
            }
            
            // Fixed collision constraint that allows movement up to contact point
            apply(pieces, movement, startPositions, mode) {
                // Only check collisions if there's meaningful movement
                if (movement.lengthSq() < 0.000001) return movement;
                
                // During dragging, allow movement but track collision state
                if (mode === 'drag') {
                    const hasCollisions = GridSnapSystem.checkCollisions(pieces, movement, startPositions);
                    app.movementState.hasCollisions = hasCollisions;
                    return movement; // Always allow movement during dragging
                }
                
                // For non-dragging modes, find maximum movement without collision
                const maxMovement = GridSnapSystem.findMaxMovementWithoutCollision(pieces, movement, startPositions);
                
                // If we couldn't move the full distance, show why
                if (maxMovement.lengthSq() < movement.lengthSq() * 0.99) {
                    const movedDistance = Math.sqrt(maxMovement.lengthSq()) * 1000; // Convert to mm
                    const requestedDistance = Math.sqrt(movement.lengthSq()) * 1000;
                    
                    if (movedDistance > 1) { // Less than 1mm movement possible
                        showStatus(`Moved ${movedDistance.toFixed(0)}mm (${requestedDistance.toFixed(0)}mm requested)`, false, 2000);
                    }
                }
                
                return maxMovement;
            }
        }
        
        class SnapConstraint extends MovementConstraint {
            constructor() {
                super('snap');
            }
            
            apply(pieces, movement, startPositions, mode) {
                // Apply grid-based snapping
                return GridSnapSystem.applySnapping(pieces, movement, startPositions);
            }
        }
        
        function unifiedMove(pieces, desiredMovement, mode = 'drag') {
            if (pieces.size === 0) return true;
            
            // Use different thresholds based on mode
            const movementThreshold = mode === 'drag' ? 0.0001 : 0.000001;
            if (desiredMovement.lengthSq() < movementThreshold) return true;
            
            // Initialize movement state if needed
            if (!app.movementState.active || app.movementState.startPositions.size === 0) {
                app.movementState.startPositions.clear();
                pieces.forEach(piece => {
                    app.movementState.startPositions.set(piece, piece.position.clone());
                });
            }
            
            // Start with desired movement
            let finalMovement = desiredMovement.clone();
            
            // Apply constraints in order
            const constraints = [
                new FloorConstraint(),
                new SnapConstraint(),
                new CollisionConstraint()
            ];
            
            constraints.forEach(constraint => {
                finalMovement = constraint.apply(pieces, finalMovement, app.movementState.startPositions, mode);
            });
            
            // Show snap preview during drag mode
            if (mode === 'drag') {
                showSnapPreview(pieces, finalMovement);
            }
            
            // For drag mode, always allow movement even if there are collisions
            if (mode === 'drag') {
                // Apply the movement regardless of collisions
                pieces.forEach(piece => {
                    const startPos = app.movementState.startPositions.get(piece);
                    if (startPos) {
                        piece.position.copy(startPos).add(finalMovement);
                    }
                });
                
                // Update state
                app.movementState.currentOffset = finalMovement;
                
                // Show measurement
                if (app.movementState.axis && finalMovement[app.movementState.axis] !== 0) { // Check if there's actual movement on the axis
                    // MODIFICATION: Remove Math.abs() to show signed distance
                    const distance = Math.round(finalMovement[app.movementState.axis] * 1000); 
                    showMeasurement(`${app.movementState.axis.toUpperCase()}: ${distance}mm`);
                } else if (app.movementState.axis && finalMovement[app.movementState.axis] === 0 && desiredMovement[app.movementState.axis] !== 0) {
                    // If movement was attempted but resulted in zero (e.g. blocked), show 0
                    showMeasurement(`${app.movementState.axis.toUpperCase()}: 0mm`);
                }
                
                updateGuideLines();
                updateInfoPanel();
                
                return true;
            }
            
            // For non-drag modes, check if movement is blocked by collision
            const isBlocked = finalMovement.lengthSq() < 0.000001 && desiredMovement.lengthSq() > movementThreshold;
            
            if (isBlocked) {
                // Only show collision warning for meaningful movement attempts
                return false;
            }
            
            // Apply the movement
            pieces.forEach(piece => {
                const startPos = app.movementState.startPositions.get(piece);
                if (startPos) {
                    piece.position.copy(startPos).add(finalMovement);
                }
            });
            
            // Update state
            app.movementState.currentOffset = finalMovement;
            
            // Show measurement
            if (app.movementState.axis && finalMovement[app.movementState.axis] !== 0) {
                // MODIFICATION: Remove Math.abs() to show signed distance
                const distance = Math.round(finalMovement[app.movementState.axis] * 1000);
                showMeasurement(`${app.movementState.axis.toUpperCase()}: ${distance}mm`);
            } else if (app.movementState.axis && finalMovement[app.movementState.axis] === 0 && desiredMovement[app.movementState.axis] !== 0) {
                 showMeasurement(`${app.movementState.axis.toUpperCase()}: 0mm`);
            }
            
            updateGuideLines();
            updateInfoPanel();
            
            return true;
        }
        
        function showSnapPreview(pieces, finalMovementOffset) { // Renamed 'offset' to 'finalMovementOffset' for clarity
            hideSnapPreview(); // Clear any existing previews

            pieces.forEach(piece => {
                // Get the mesh from the piece group
                const mesh = piece.getObjectByName('mesh');
                if (!mesh) {
                    console.warn("Snap preview: Mesh not found for piece:", piece.userData.id || piece);
                    return;
                }

                // Get the starting position of this piece at the beginning of the current movement operation
                const startPos = app.movementState.startPositions.get(piece);
                if (!startPos) {
                    // This case should ideally not happen if movementState is managed correctly
                    console.warn("Snap preview: startPosition not found for piece:", piece.userData.id || piece);
                    return;
                }

                // Create wireframe ghost using the mesh's current geometry
                // This ensures the preview matches the piece's shape, especially if length editing is involved
                const edges = new THREE.EdgesGeometry(mesh.geometry);
                const lineMaterial = new THREE.LineDashedMaterial({
                    color: 0x4fc3f7,       // Blue color for the preview
                    linewidth: 1,          // Note: linewidth > 1 has limitations in WebGL for these materials
                    dashSize: 0.02,        // Length of the dashes
                    gapSize: 0.01,         // Length of the gaps
                    opacity: 0.5,          // Semi-transparent
                    transparent: true
                });
                const ghost = new THREE.LineSegments(edges, lineMaterial);
                ghost.computeLineDistances(); // Necessary for dashed lines to render correctly

                // Position the ghost: Start from the piece's original position at the beginning of the drag,
                // then add the total calculated (snapped) offset for the current drag state.
                ghost.position.copy(startPos).add(finalMovementOffset);

                // Match the orientation and scale of the actual piece
                ghost.quaternion.copy(piece.quaternion);
                ghost.scale.copy(piece.scale);

                ghost.userData.isSnapPreview = true; // Mark this object as a snap preview

                app.scene.add(ghost); // Add the ghost to the scene
                app.snapGhosts.set(piece, ghost); // Keep track of the ghost associated with each piece
            });
        }
        
        function hideSnapPreview() {
            app.snapGhosts.forEach(ghost => {
                app.scene.remove(ghost);
                if (ghost.geometry) ghost.geometry.dispose();
                if (ghost.material) ghost.material.dispose();
            });
            app.snapGhosts.clear();
        }
        
        function startMovement(mode, axis = null) {
            app.movementState.active = true;
            app.movementState.mode = mode;
            app.movementState.axis = axis;
            app.movementState.currentOffset.set(0, 0, 0);
            app.movementState.typedValue = '';
            app.movementState.hasCollisions = false;
            app.movementState.startPositions.clear();
            
            app.selectedPieces.forEach(piece => {
                app.movementState.startPositions.set(piece, piece.position.clone());
            });
            
            // For free movement, establish a stable reference plane at the start
            if (axis === 'free') {
                // Calculate the center of selected pieces at movement start
                const startCenter = new THREE.Vector3();
                app.movementState.startPositions.forEach(pos => startCenter.add(pos));
                startCenter.divideScalar(app.movementState.startPositions.size);
                
                // Create a stable plane perpendicular to camera at the initial center position
                const cameraDirection = new THREE.Vector3();
                app.camera.getWorldDirection(cameraDirection);
                app.movementState.referencePlane = new THREE.Plane(cameraDirection, -cameraDirection.dot(startCenter));
                app.movementState.referenceCenter = startCenter.clone();
                
                // Store the initial mouse intersection point
                app.raycaster.setFromCamera(app.mouse, app.camera);
                const initialIntersection = new THREE.Vector3();
                app.raycaster.ray.intersectPlane(app.movementState.referencePlane, initialIntersection);
                app.movementState.initialIntersection = initialIntersection || startCenter.clone();
            }
            
            // Clear any collision warnings when starting movement
            app.selectedPieces.forEach(piece => {
                piece.userData.isColliding = false;
                updatePieceAppearance(piece);
            });
            
            updateGuideLines();
            updateHotkeyGuide();
            
            // Force a quick collision check to ensure current states
            setTimeout(() => checkCollisions(), 10);
        }
        
        function endMovement(save = true) {
            hideSnapPreview();
            
            if (app.movementState.active && save) {
                const movedDistance = app.movementState.currentOffset.lengthSq();
                if (movedDistance > 0.000001) {
                    // If there were collisions during drag movement, try to snap to a safe position
                    if (app.movementState.hasCollisions && app.movementState.mode === 'drag') {
                        const safePositions = findSafePositionsForPieces(app.selectedPieces);
                        if (safePositions.size > 0) {
                            safePositions.forEach((position, piece) => {
                                piece.position.copy(position);
                            });
                        }
                    }
                    
                    saveState();
                    saveCurrentProject();
                    // Force a collision check after movement to update collision states
                    checkCollisions();
                    updateProjectDetails();
                }
            }
            
            app.movementState.active = false;
            app.movementState.mode = null;
            app.movementState.axis = null;
            app.movementState.currentOffset.set(0, 0, 0);
            app.movementState.startPositions.clear();
            app.movementState.typedValue = '';
            app.movementState.isDragging = false;
            app.movementState.hasCollisions = false;
            
            // Clear reference plane data for free movement
            app.movementState.referencePlane = null;
            app.movementState.referenceCenter = null;
            app.movementState.initialIntersection = null;
            
            clearGuideLines();
            hideMeasurement();
            hideSnapIndicator();
            updateHotkeyGuide();
            
            // Force collision check to ensure states are current
            checkCollisions();
        }
        
        function findSafePositionsForPieces(pieces) {
            const safePositions = new Map();
            
            pieces.forEach(piece => {
                const originalPosition = piece.position.clone();
                
                // Try to find a safe position
                if (GridSnapSystem.findSafePosition(piece, originalPosition, pieces)) {
                    safePositions.set(piece, piece.position.clone());
                } else {
                    // If no safe position found, restore original
                    piece.position.copy(originalPosition);
                }
            });
            
            return safePositions;
        }
        
        // --- END UNIFIED MOVEMENT SYSTEM ---
        
        // --- INTEGRATED PIECE RENDERING SYSTEM ---
        
        function createUnifiedWoodPiece(thickness, width, length = 500) {
            // Create the main group that will contain both mesh and outline
            const pieceGroup = new THREE.Group();
            
            // Create the mesh
            const t = thickness / 1000;
            const w = width / 1000;
            const l = length / 1000;
            const geometry = createRoundedBoxGeometry(t, w, l, 0.003, 4);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xB8956F, 
                roughness: 0.6, 
                metalness: 0.05 
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.name = 'mesh'; // Name it so we can find it later
            
            // Create the outline (initially hidden)
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x4fc3f7, 
                linewidth: 2 
            });
            const outline = new THREE.LineSegments(edges, lineMaterial);
            outline.name = 'outline';
            outline.visible = false; // Hidden by default
            
            // Add both to the group
            pieceGroup.add(mesh);
            pieceGroup.add(outline);
            
            // Add unique ID for better collision debugging
            const pieceId = 'piece_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            pieceGroup.userData = { 
                thickness, 
                width, 
                length, 
                isWoodPiece: true, 
                geometryVersion: 1,
                id: pieceId,
                isSelected: false,
                isColliding: false
            };
            
            const halfLength = l / 2; 
            const preferredPosition = new THREE.Vector3(
                snapToGrid(app.cameraTarget.x),
                snapToGrid(app.cameraTarget.y),
                Math.max(halfLength, 0)
            );
            
            app.scene.add(pieceGroup);
            GridSnapSystem.findSafePosition(pieceGroup, preferredPosition);
            
            return pieceGroup;
        }
        
        function updatePieceAppearance(piece) {
            const mesh = piece.getObjectByName('mesh');
            const outline = piece.getObjectByName('outline');
            
            if (!mesh || !outline) return;
            
            // Update selection outline visibility
            outline.visible = piece.userData.isSelected;
            
            // Update mesh color based on state
            if (piece.userData.isColliding) {
                mesh.material.color.setHex(0xff4444); // Red for collision
            } else {
                mesh.material.color.setHex(0xB8956F); // Normal wood color
            }
        }
        
        function createResizeIndicator(piece, face) {
            // Remove any existing resize indicator
            const existingIndicator = piece.getObjectByName('resizeIndicator');
            if (existingIndicator) {
                piece.remove(existingIndicator);
                existingIndicator.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            
            const { thickness, width } = piece.userData; 
            const length = piece.userData.currentPreviewLength || piece.userData.length; 

            const t_m = thickness / 1000;
            const w_m = width / 1000;
            const l_m = length / 1000;
            
            const z = face === 'top' ? l_m / 2 : -l_m / 2;
            const cylinderRadius = 0.002;
            const edgeGroup = new THREE.Group();
            edgeGroup.name = 'resizeIndicator';
            
            const corners = [
                new THREE.Vector3(-t_m/2, -w_m/2, z), new THREE.Vector3(t_m/2, -w_m/2, z),
                new THREE.Vector3(t_m/2, w_m/2, z), new THREE.Vector3(-t_m/2, w_m/2, z)
            ];

            for (let i = 0; i < 4; i++) {
                const start = corners[i];
                const end = corners[(i + 1) % 4];
                const edgeVector = end.clone().sub(start);
                const edgeLength = edgeVector.length();
                const edgeCenter = start.clone().add(end).multiplyScalar(0.5);
                
                const cylinderGeometry = new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, edgeLength, 8);
                const cylinderMaterial = new THREE.MeshBasicMaterial({ color: 0x0d47a1 });
                const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                
                cylinder.position.copy(edgeCenter);
                if (edgeLength > 0) {
                    cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), edgeVector.clone().normalize());
                }
                edgeGroup.add(cylinder);
            }
            
            // Position the indicator with offset
            const offsetFactor = 0.0015; 
            const offsetVector = new THREE.Vector3(0, 0, face === 'top' ? offsetFactor : -offsetFactor);
            edgeGroup.position.copy(offsetVector);
            
            piece.add(edgeGroup);
        }

        function removeResizeIndicator(piece) {
            const indicator = piece.getObjectByName('resizeIndicator');
            if (indicator) {
                piece.remove(indicator);
                indicator.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
        }
        
        // --- END INTEGRATED PIECE RENDERING SYSTEM ---
        
        function loadCollapsedState() {
            try {
                const saved = localStorage.getItem('woodCollapsedThicknesses');
                if (saved) {
                    const collapsed = JSON.parse(saved);
                    app.collapsedThicknesses = new Set(collapsed);
                }
            } catch (e) {
                console.error('Failed to load collapsed state:', e);
                app.collapsedThicknesses = new Set();
            }
        }
        
        function saveCollapsedState() {
            try {
                localStorage.setItem('woodCollapsedThicknesses', JSON.stringify(Array.from(app.collapsedThicknesses)));
            } catch (e) {
                console.error('Failed to save collapsed state:', e);
            }
        }
        
        function toggleThicknessGroup(thickness) {
            const groupElement = document.querySelector(`[data-thickness-group="${thickness}"]`);
            if (!groupElement) return;
            
            if (app.collapsedThicknesses.has(thickness)) {
                app.collapsedThicknesses.delete(thickness);
                groupElement.classList.remove('collapsed');
            } else {
                app.collapsedThicknesses.add(thickness);
                groupElement.classList.add('collapsed');
            }
            saveCollapsedState();
        }
        
        function calculateLumberCost(thickness, width) {
            const crossSection = thickness * width; // mm²
            let baseCostPerMm2 = 0.008; 
            if (thickness >= 98 || width >= 98) baseCostPerMm2 *= 1.4;
            if (thickness >= 48 && width >= 148) baseCostPerMm2 *= 0.95;
            if (thickness === 98 && width === 98) return 119;
            if (thickness === 48 && width === 148) return 54.9;
            if (thickness === 48 && width === 98) return 33.8;
            if (thickness === 48 && width === 198) return 76.9;
            const pricePerMeter = crossSection * baseCostPerMm2;
            return Math.round(pricePerMeter * 10) / 10;
        }
        
        function snapToGrid(value) {
            return GridSnapSystem.snapToGrid(value);
        }
        
        function snapVectorToGrid(vector) {
            return GridSnapSystem.snapVectorToGrid(vector);
        }
        
        app.toggleGridSnap = function() {
            app.gridSnapEnabled = !app.gridSnapEnabled;
            document.getElementById('gridToggle').classList.toggle('active', app.gridSnapEnabled);
            
            // Grid snap is always enabled in this system
            if (!app.gridSnapEnabled) {
                app.gridSnapEnabled = true;
                document.getElementById('gridToggle').classList.add('active');
                showStatus('Grid snap is required for proper alignment', true, 3000);
            } else {
                showStatus('Grid snap enabled');
            }
            
            // Save grid snap setting
            try {
                localStorage.setItem('gridSnapEnabled', JSON.stringify(app.gridSnapEnabled));
            } catch (e) {
                console.error('Failed to save grid snap setting:', e);
            }
            
            updateProjectDetails();
        };

        app.toggleHotkeyGuide = function() {
            app.hotkeyGuideEnabled = !app.hotkeyGuideEnabled;
            document.getElementById('hotkeyToggle').classList.toggle('active', app.hotkeyGuideEnabled);
            
            const guide = document.getElementById('hotkeyGuide');
            if (!app.hotkeyGuideEnabled) {
                guide.classList.add('hidden');
            } else {
                // Re-enable activity-based hiding
                trackActivity();
            }
            
            showStatus(`Hotkey guide ${app.hotkeyGuideEnabled ? 'enabled' : 'disabled'}`);
            
            // Save hotkey guide setting
            try {
                localStorage.setItem('hotkeyGuideEnabled', JSON.stringify(app.hotkeyGuideEnabled));
            } catch (e) {
                console.error('Failed to save hotkey guide setting:', e);
            }
        };
        
        function updateProjectDetails() {
            let totalCost = 0;
            let totalWeight = 0;
            let totalPieces = 0;
            const materialUsage = {};
            
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece) {
                    totalPieces++;
                    const { thickness, width, length } = obj.userData;
                    const lengthInMeters = length / 1000;
                    const costPerMeter = calculateLumberCost(thickness, width);
                    totalCost += costPerMeter * lengthInMeters;
                    const volumeInCm3 = (thickness / 10) * (width / 10) * (length / 10);
                    totalWeight += (volumeInCm3 * app.woodDensity) / 1000;
                    const key = `${thickness}×${width}mm`;
                    materialUsage[key] = (materialUsage[key] || 0) + lengthInMeters;
                }
            });
            
            document.getElementById('totalCost').textContent = `${totalCost.toFixed(0)} kr`;
            document.getElementById('totalWeight').textContent = `${totalWeight.toFixed(1)} kg`;
            document.getElementById('totalPieces').textContent = totalPieces.toString();
            
            const breakdownDiv = document.getElementById('materialsBreakdown');
            breakdownDiv.innerHTML = '';
            Object.entries(materialUsage).sort().forEach(([dimension, meters]) => {
                const item = document.createElement('div');
                item.className = 'material-item';
                item.innerHTML = `<span>${dimension}</span><span>${meters.toFixed(2)}m</span>`;
                breakdownDiv.appendChild(item);
            });
        }
        
        function trackActivity() {
            app.lastActivity = Date.now();
            
            // Only show hotkey guide if it's enabled
            if (app.hotkeyGuideEnabled) {
                document.getElementById('hotkeyGuide').classList.remove('hidden');
                clearTimeout(app.activityTimeout);
                app.activityTimeout = setTimeout(() => {
                    if (Date.now() - app.lastActivity >= 5000 && app.hotkeyGuideEnabled) {
                        document.getElementById('hotkeyGuide').classList.add('hidden');
                    }
                }, 5000);
            }
        }

        function loadSettings() {
            // Load grid snap setting
            try {
                const savedGridSnap = localStorage.getItem('gridSnapEnabled');
                app.gridSnapEnabled = savedGridSnap ? JSON.parse(savedGridSnap) : true;
            } catch (e) {
                console.error('Failed to load grid snap setting:', e);
                app.gridSnapEnabled = true;
            }
            
            // Load hotkey guide setting
            try {
                const savedHotkeyGuide = localStorage.getItem('hotkeyGuideEnabled');
                app.hotkeyGuideEnabled = savedHotkeyGuide ? JSON.parse(savedHotkeyGuide) : true;
            } catch (e) {
                console.error('Failed to load hotkey guide setting:', e);
                app.hotkeyGuideEnabled = true;
            }
            
            // Load settings panel expanded state
            try {
                const savedSettingsExpanded = localStorage.getItem('settingsPanelExpanded');
                app.settingsPanelExpanded = savedSettingsExpanded ? JSON.parse(savedSettingsExpanded) : false;
            } catch (e) {
                console.error('Failed to load settings panel state:', e);
                app.settingsPanelExpanded = false;
            }
        }

        function applySettings() {
            // Apply grid snap setting
            const gridToggleElement = document.getElementById('gridToggle');
            if (gridToggleElement) {
                gridToggleElement.classList.toggle('active', app.gridSnapEnabled);
            }
            
            // Apply hotkey guide setting
            const hotkeyToggleElement = document.getElementById('hotkeyToggle');
            if (hotkeyToggleElement) {
                hotkeyToggleElement.classList.toggle('active', app.hotkeyGuideEnabled);
            }
            
            // Apply settings panel expanded state
            const settingsContent = document.getElementById('settingsContent');
            const settingsButton = document.getElementById('settingsButton');
            if (settingsContent && settingsButton) {
                if (app.settingsPanelExpanded) {
                    settingsContent.classList.add('expanded');
                    settingsButton.classList.add('active');
                } else {
                    settingsContent.classList.remove('expanded');
                    settingsButton.classList.remove('active');
                }
            }
            
            // Apply hotkey guide visibility
            const hotkeyGuide = document.getElementById('hotkeyGuide');
            if (hotkeyGuide && !app.hotkeyGuideEnabled) {
                hotkeyGuide.classList.add('hidden');
            }
        }

        function toggleMenu() {
            const panel = document.getElementById('sidePanel');
            const button = document.getElementById('menuButton');
            const overlay = document.getElementById('menuOverlay');
            panel.classList.toggle('active');
            button.classList.toggle('active');
            overlay.classList.toggle('active');
            trackActivity();
        }

        function closeMenu() {
            document.getElementById('sidePanel').classList.remove('active');
            document.getElementById('menuButton').classList.remove('active');
            document.getElementById('menuOverlay').classList.remove('active');
        }
        
        function toggleSettingsSection() {
            const content = document.getElementById('settingsContent');
            const button = document.getElementById('settingsButton');
            
            content.classList.toggle('expanded');
            button.classList.toggle('active');
            
            // Save settings panel state
            try {
                const isExpanded = content.classList.contains('expanded');
                localStorage.setItem('settingsPanelExpanded', JSON.stringify(isExpanded));
            } catch (e) {
                console.error('Failed to save settings panel state:', e);
            }
            
            trackActivity();
        }
        
        function showStatus(message, isError = false, duration = 2000) {
            const status = document.getElementById('statusIndicator');
            status.textContent = message;
            status.style.backgroundColor = isError ? 'rgba(211, 47, 47, 0.9)' : 'rgba(33, 150, 243, 0.9)';
            status.classList.remove('hidden');
            clearTimeout(app.statusTimeout);
            app.statusTimeout = setTimeout(() => status.classList.add('hidden'), duration);
        }
        
        function showSnapIndicator(text) {
            const indicator = document.getElementById('snapIndicator');
            indicator.textContent = text;
            indicator.classList.remove('hidden');
            
            // Position near cursor
            const x = app.lastMouseX + 20;
            const y = app.lastMouseY - 20;
            indicator.style.left = `${x}px`;
            indicator.style.top = `${y}px`;
            
            clearTimeout(indicator.hideTimeout);
            indicator.hideTimeout = setTimeout(() => {
                indicator.classList.add('hidden');
            }, 1000);
        }
        
        function hideSnapIndicator() {
            const indicator = document.getElementById('snapIndicator');
            indicator.classList.add('hidden');
        }
        
        function checkCollisions() {
            const collisions = GridSnapSystem.checkSceneCollisions();
            
            // Reset all pieces to normal state
            const allPieces = app.scene.children.filter(obj => obj.userData.isWoodPiece);
            allPieces.forEach(piece => {
                piece.userData.isColliding = false;
                updatePieceAppearance(piece);
            });
            
            // Apply collision state
            collisions.forEach(piece => {
                piece.userData.isColliding = true;
                updatePieceAppearance(piece);
            });
            
            updateInfoPanel();
        }
        
        function calculatePieceInfo(piece) {
            const { thickness, width, length } = piece.userData;
            const volumeInCm3 = (thickness / 10) * (width / 10) * (length / 10);
            const weightInKg = (volumeInCm3 * app.woodDensity) / 1000;
            const costPerMeter = calculateLumberCost(thickness, width);
            const cost = costPerMeter * (length / 1000);
            
            // Use centralized bounds calculation for height
            piece.updateMatrixWorld(true);
            const bounds = GridSnapSystem.getAlignedBounds(piece);
            const heightAboveFloor = Math.max(0, bounds.min.z * 1000);
            
            return { 
                dimensions: `${thickness}×${width}×${length}mm`, 
                volume: volumeInCm3, 
                weight: weightInKg, 
                cost: cost, 
                costPerMeter: costPerMeter, 
                heightAboveFloor: heightAboveFloor 
            };
        }
        
        function updateInfoPanel() {
            const infoPanel = document.getElementById('infoPanel');
            const infoContent = document.getElementById('infoContent');
            
            if (app.selectedPieces.size === 0) {
                infoPanel.classList.add('hidden');
                return;
            }
            
            infoPanel.classList.remove('hidden');
            let totalVolume = 0, totalWeight = 0, totalCost = 0, infoHtml = '';
            
            if (app.selectedPieces.size === 1) {
                const piece = Array.from(app.selectedPieces)[0];
                const info = calculatePieceInfo(piece);
                infoHtml = `<div class="info-row"><span class="info-label">Dimensions:</span><span class="info-value">${info.dimensions}</span></div>` +
                           `<div class="info-row"><span class="info-label">Height:</span><span class="info-value">${Math.round(info.heightAboveFloor)}mm</span></div>` +
                           `<div class="info-row"><span class="info-label">Volume:</span><span class="info-value">${info.volume.toFixed(1)}cm³</span></div>` +
                           `<div class="info-row"><span class="info-label">Weight:</span><span class="info-value">${info.weight.toFixed(2)}kg</span></div>` +
                           `<div class="info-row"><span class="info-label">Cost:</span><span class="info-value">${info.cost.toFixed(2)}kr</span></div>` +
                           `<div class="info-row"><span class="info-label">Price/m:</span><span class="info-value">${info.costPerMeter.toFixed(1)}kr</span></div>`;
            } else {
                app.selectedPieces.forEach(piece => {
                    const info = calculatePieceInfo(piece);
                    totalVolume += info.volume;
                    totalWeight += info.weight;
                    totalCost += info.cost;
                });
                infoHtml = `<div class="info-row"><span class="info-label">Pieces:</span><span class="info-value">${app.selectedPieces.size}</span></div>` +
                           `<div class="info-row"><span class="info-label">Total Volume:</span><span class="info-value">${totalVolume.toFixed(1)}cm³</span></div>` +
                           `<div class="info-row"><span class="info-label">Total Weight:</span><span class="info-value">${totalWeight.toFixed(2)}kg</span></div>` +
                           `<div class="info-row"><span class="info-label">Total Cost:</span><span class="info-value">${totalCost.toFixed(2)}kr</span></div>`;
            }
            
            let hasCollisions = false;
            app.selectedPieces.forEach(piece => {
                if (piece.userData.isColliding) hasCollisions = true;
            });
            
            if (hasCollisions) {
                infoHtml += '<div class="collision-warning">⚠️ Collision detected!</div>';
            }
            
            infoContent.innerHTML = infoHtml;
        }
        
        function init() {
            app.scene = new THREE.Scene();
            app.scene.background = new THREE.Color(0x1a1a1a);
            app.scene.fog = new THREE.Fog(0x1a1a1a, 10, 50);
            
            app.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();
            
            const canvas = document.getElementById('canvas');
            app.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            app.renderer.setSize(window.innerWidth, window.innerHeight);
            app.renderer.shadowMap.enabled = true;
            app.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            app.scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(5, -5, 10);
            directionalLight1.castShadow = true;
            directionalLight1.shadow.camera.left = -10;
            directionalLight1.shadow.camera.right = 10;
            directionalLight1.shadow.camera.top = 10;
            directionalLight1.shadow.camera.bottom = -10;
            directionalLight1.shadow.mapSize.width = 2048;
            directionalLight1.shadow.mapSize.height = 2048;
            app.scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-3, 3, 8);
            app.scene.add(directionalLight2);
            
            const fillLight = new THREE.DirectionalLight(0x4fc3f7, 0.2);
            fillLight.position.set(0, 0, -5);
            app.scene.add(fillLight);
            
            const groundGeometry = new THREE.BoxGeometry(40, 40, 0.1);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.9, metalness: 0.1 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.position.z = -0.05;
            ground.receiveShadow = true;
            ground.userData.isGround = true;
            app.scene.add(ground);
            
            const gridHelper = new THREE.GridHelper(40, 80, 0x555555, 0x3a3a3a);
            gridHelper.rotation.x = Math.PI / 2;
            gridHelper.position.z = 0.001;
            app.scene.add(gridHelper);
            
            loadCollapsedState();
            loadSettings();
            initializeMaterialPanel();
            loadProjects(); 
            
            // Apply all loaded settings to UI
            applySettings();

            app.measurementElement = document.getElementById('measurement');
            
            setupEventListeners();
            document.getElementById('loading').style.display = 'none';
            trackActivity();
            animate();
        }
        
        function updateCameraPosition() {
            app.camera.position.x = app.cameraTarget.x + app.cameraDistance * Math.sin(app.cameraPhi) * Math.cos(app.cameraTheta);
            app.camera.position.y = app.cameraTarget.y + app.cameraDistance * Math.sin(app.cameraPhi) * Math.sin(app.cameraTheta);
            app.camera.position.z = app.cameraTarget.z + app.cameraDistance * Math.cos(app.cameraPhi);
            app.camera.up.set(0, 0, 1);
            app.camera.lookAt(app.cameraTarget);
        }
        
        function initializeMaterialPanel() {
            const materialList = document.getElementById('materialList');
            app.woodDimensions.forEach((group) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'thickness-group';
                groupDiv.setAttribute('data-thickness-group', group.thickness);
                if (app.collapsedThicknesses.has(group.thickness)) groupDiv.classList.add('collapsed');
                
                const header = document.createElement('div');
                header.className = 'thickness-header';
                header.onclick = () => toggleThicknessGroup(group.thickness);
                
                const title = document.createElement('h4');
                title.textContent = `${group.thickness}mm Thickness`;
                
                const collapseIcon = document.createElement('div');
                collapseIcon.className = 'collapse-icon';
                
                header.append(title, collapseIcon);
                groupDiv.appendChild(header);
                
                const widthOptionsDiv = document.createElement('div');
                widthOptionsDiv.className = 'width-options';
                
                group.widths.forEach((width) => {
                    const option = document.createElement('div');
                    option.className = 'wood-option';
                    option.dataset.thickness = group.thickness;
                    option.dataset.width = width;
                    
                    const iconCanvas = document.createElement('canvas');
                    iconCanvas.className = 'wood-icon';
                    iconCanvas.width = 60;
                    iconCanvas.height = 20;
                    const ctx = iconCanvas.getContext('2d');
                    const scale = 0.3;
                    const w = Math.min(width * scale, 55);
                    const t = group.thickness * scale * 0.3;
                    const x = (60 - w) / 2;
                    const y = (20 - t) / 2;
                    ctx.fillStyle = '#8B6F47';
                    ctx.fillRect(x, y, w, t);
                    ctx.strokeStyle = '#6B5637';
                    ctx.strokeRect(x, y, w, t);
                    
                    const label = document.createElement('div');
                    label.className = 'wood-label';
                    label.textContent = `${width}mm`;
                    
                    option.append(iconCanvas, label);
                    option.addEventListener('click', () => {
                        selectWoodDimension(group.thickness, width);
                        closeMenu();
                    });
                    
                    widthOptionsDiv.appendChild(option);
                });
                
                groupDiv.appendChild(widthOptionsDiv);
                materialList.appendChild(groupDiv);
            });
        }
        
        function selectWoodDimension(thickness, width) {
            document.querySelectorAll('.wood-option.active').forEach(opt => opt.classList.remove('active'));
            const selectedOpt = document.querySelector(`.wood-option[data-thickness="${thickness}"][data-width="${width}"]`);
            if (selectedOpt) selectedOpt.classList.add('active');
            
            app.selectedDimension = { thickness, width };
            const key = `${thickness}x${width}`;
            app.recentDimensions = app.recentDimensions.filter(d => d !== key);
            app.recentDimensions.unshift(key);
            if (app.recentDimensions.length > 10) app.recentDimensions.pop();
            
            createWoodPiece(thickness, width);
        }
        
        function createRoundedBoxGeometry(width, height, depth, radius = 0.003, bevelSegments = 4) {
            const shape = new THREE.Shape();
            const w = width / 2 - radius;
            const h = height / 2 - radius;
            
            shape.moveTo(-w, -h); 
            shape.lineTo(w, -h);  
            shape.quadraticCurveTo(w + radius, -h, w + radius, -h + radius); 
            shape.lineTo(w + radius, h); 
            shape.quadraticCurveTo(w + radius, h + radius, w, h + radius); 
            shape.lineTo(-w, h + radius); 
            shape.quadraticCurveTo(-w - radius, h + radius, -w - radius, h); 
            shape.lineTo(-w - radius, -h + radius); 
            shape.quadraticCurveTo(-w - radius, -h, -w, -h); 

            const extrudeSettings = {
                depth: depth,
                bevelEnabled: true,
                bevelSegments: bevelSegments, 
                steps: 1,
                bevelSize: radius, 
                bevelThickness: radius 
            };
            
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.center(); 
            return geometry;
        }
        
        function createWoodPiece(thickness, width, length = 500) {
            const piece = createUnifiedWoodPiece(thickness, width, length);
            
            clearSelection();
            app.selectedPieces.add(piece);
            updatePieceSelection(piece, true);
            
            saveState();
            saveCurrentProject();
            updateHotkeyGuide();
            updateInfoPanel();
            updateProjectDetails();
            checkCollisions();
            showStatus(`Created ${thickness}×${width}mm piece`);
        }
        
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('contextmenu', e => e.preventDefault());
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('wheel', onMouseWheel, { passive: false }); 
            document.addEventListener('click', handleDocumentClickForInputs, true);
        }
        
        function onWindowResize() {
            app.camera.aspect = window.innerWidth / window.innerHeight;
            app.camera.updateProjectionMatrix();
            app.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onMouseDown(event) {
            trackActivity();

            // Prevent canvas interaction if the click is on UI elements within the side panel
            if (event.target.closest('.project-actions') ||
                event.target.closest('.project-delete-confirm') ||
                event.target.closest('.project-edit-form') ||
                event.target.closest('.new-project-input-item')) {
                return;
            }

            if (event.target.id !== 'canvas') return; // Only process clicks on the canvas
            updateMouse(event); // Update mouse coordinates for raycasting

            if (event.button === 0) { // Left mouse button
                app.mouseDown = true;
                app.raycaster.setFromCamera(app.mouse, app.camera);

                // Filter for piece groups and their meshes for raycasting
                const raycastTargets = [];
                app.scene.children.filter(obj => obj.userData.isWoodPiece).forEach(pieceGroup => {
                    const mesh = pieceGroup.getObjectByName('mesh');
                    if (mesh) raycastTargets.push(mesh);
                });

                const intersects = app.raycaster.intersectObjects(raycastTargets, false);

                if (intersects.length > 0) {
                    const clickedMesh = intersects[0].object;
                    const clickedPiece = clickedMesh.parent; // The piece group is the parent of the mesh

                    if (app.keys['v'] && app.selectedPieces.has(clickedPiece)) {
                        // --- LENGTH EDIT MODE ---
                        const intersectionPointWorld = intersects[0].point.clone();
                        // Convert the world intersection point to the piece's local coordinate system
                        const localIntersectionPoint = clickedPiece.worldToLocal(intersectionPointWorld.clone());

                        // Get piece dimensions in meters
                        const pieceLengthM = clickedPiece.userData.length / 1000;
                        const pieceThicknessM = clickedPiece.userData.thickness / 1000;
                        const pieceWidthM = clickedPiece.userData.width / 1000;

                        const halfLengthM = pieceLengthM / 2;
                        const halfThicknessM = pieceThicknessM / 2;
                        const halfWidthM = pieceWidthM / 2;

                        // Tolerance for detecting a click on an end cap surface (e.g., 20mm)
                        const clickToleranceZ = GridSnapSystem.FACE_SNAP_THRESHOLD || 0.020;

                        let determinedEditFace = null;

                        // Check if the click is within the X and Y bounds of the piece (in its local space)
                        // and if its Z coordinate is close to one of the ends.
                        if (Math.abs(localIntersectionPoint.x) <= halfThicknessM + FLOAT_PRECISION &&
                            Math.abs(localIntersectionPoint.y) <= halfWidthM + FLOAT_PRECISION) {

                            if (Math.abs(localIntersectionPoint.z - halfLengthM) < clickToleranceZ) {
                                determinedEditFace = 'top'; // Clicked near the positive Z end (local +Z)
                            } else if (Math.abs(localIntersectionPoint.z + halfLengthM) < clickToleranceZ) {
                                determinedEditFace = 'bottom'; // Clicked near the negative Z end (local -Z)
                            }
                        }

                        if (determinedEditFace) {
                            app.movementState.lengthEditData = {
                                pieces: new Set(app.selectedPieces),
                                pieceData: new Map(),
                                startMouseX: event.clientX // Using clientX for direct mouse delta later
                            };

                            app.selectedPieces.forEach(p => {
                                app.movementState.lengthEditData.pieceData.set(p, {
                                    originalLength: p.userData.length,
                                    originalPosition: p.position.clone(),
                                    originalQuaternion: p.quaternion.clone(),
                                    editFace: determinedEditFace
                                });
                                createResizeIndicator(p, determinedEditFace);
                            });

                            showStatus(`Length edit mode (${app.selectedPieces.size} pieces). Drag or type value.`);
                            updateHotkeyGuide();
                        } else {
                            showStatus('Click an end-face (along length) to adjust length with V.', true);
                        }
                    } else if (app.keys['e']) { // Duplicate piece (E key + Click)
                        duplicatePiece(clickedPiece); // Assumes duplicatePiece handles selection update
                    } else if (app.movementState.axis && app.selectedPieces.has(clickedPiece)) {
                        // Start axis-constrained drag if an axis key (X, C, Z) is already held
                        // and the clicked piece is part of the selection.
                        startMovement('drag', app.movementState.axis);
                        app.movementState.isDragging = true;
                    } else {
                        // --- SELECTION LOGIC & FREE DRAG START ---
                        if (event.ctrlKey) { // Ctrl + Click for multi-select
                            if (app.selectedPieces.has(clickedPiece)) {
                                app.selectedPieces.delete(clickedPiece);
                                updatePieceSelection(clickedPiece, false);
                            } else {
                                app.selectedPieces.add(clickedPiece);
                                updatePieceSelection(clickedPiece, true);
                            }
                        } else { // Standard click
                            if (!app.selectedPieces.has(clickedPiece)) {
                                // If clicked piece is not selected, clear current selection and select it
                                clearSelection();
                                app.selectedPieces.add(clickedPiece);
                                updatePieceSelection(clickedPiece, true);
                            }
                            // If the clicked piece is already selected (or just got selected), start free drag.
                            // This allows dragging a single already-selected piece without deselecting others if it's part of a group.
                            // However, if you want single click to ALWAYS select ONLY the clicked piece and start drag:
                            // clearSelection(); app.selectedPieces.add(clickedPiece); updatePieceSelection(clickedPiece, true);
                            startMovement('drag', 'free');
                            app.movementState.isDragging = true;
                        }
                        updateHotkeyGuide();
                        updateInfoPanel();
                    }
                } else if (!event.ctrlKey && !app.movementState.axis) {
                    // Clicked on empty space (no piece intersected)
                    // and not holding Ctrl (for multi-select)
                    // and not in an axis-movement mode (X,C,Z keys)
                    clearSelection();
                    updateHotkeyGuide();
                    updateInfoPanel();
                }
            } else if (event.button === 2) { // Right mouse button
                app.rightMouseDown = true;
            }

            app.lastMouseX = event.clientX;
            app.lastMouseY = event.clientY;
            if (app.mouseDown || app.rightMouseDown) {
                document.getElementById('canvas').classList.add('grabbing');
            }
        }
        
        function onMouseMove(event) {
            trackActivity();
            if (!app.camera || !app.renderer) return;

            const deltaX = event.clientX - app.lastMouseX;
            const deltaY = event.clientY - app.lastMouseY;
            updateMouse(event);

            if (app.movementState.isDragging && app.movementState.active) {
                // Handle piece movement
                if (app.movementState.axis === 'z') {
                    // Z-axis movement based on vertical mouse movement
                    const zMoveSensitivity = 0.002;
                    const zDelta = -deltaY * zMoveSensitivity * (app.cameraDistance / 3);
                    const movement = new THREE.Vector3(0, 0, zDelta);
                    const totalMovement = app.movementState.currentOffset.clone().add(movement);
                    unifiedMove(app.selectedPieces, totalMovement, 'drag');
                } else if (app.movementState.axis === 'x') {
                    // X-axis movement based on horizontal mouse movement
                    const sensitivity = 0.003 * (app.cameraDistance / 3);
                    const xDelta = deltaX * sensitivity;
                    const movement = new THREE.Vector3(xDelta, 0, 0);
                    const totalMovement = app.movementState.currentOffset.clone().add(movement);
                    unifiedMove(app.selectedPieces, totalMovement, 'drag');
                } else if (app.movementState.axis === 'y') {
                    // Y-axis movement based on vertical mouse movement  
                    const sensitivity = 0.003 * (app.cameraDistance / 3);
                    const yDelta = -deltaY * sensitivity;
                    const movement = new THREE.Vector3(0, yDelta, 0);
                    const totalMovement = app.movementState.currentOffset.clone().add(movement);
                    unifiedMove(app.selectedPieces, totalMovement, 'drag');
                } else if (app.movementState.axis === 'free') {
                    // Free movement using stable reference plane (no flickering)
                    if (app.movementState.referencePlane && app.movementState.initialIntersection) {
                        app.raycaster.setFromCamera(app.mouse, app.camera);
                        
                        // Get current intersection with the STABLE reference plane
                        const currentIntersection = new THREE.Vector3();
                        const intersected = app.raycaster.ray.intersectPlane(app.movementState.referencePlane, currentIntersection);
                        
                        if (intersected) {
                            // Calculate movement as difference from initial intersection point
                            const movement = currentIntersection.clone().sub(app.movementState.initialIntersection);
                            
                            // Optional: Project movement onto XY plane if you want to prevent Z movement during free drag
                            // movement.z = 0;
                            
                            unifiedMove(app.selectedPieces, movement, 'drag');
                        }
                    }
                }
            } else if (app.movementState.lengthEditData) {
                // Handle length editing
                const mouseDelta = event.clientX - app.movementState.lengthEditData.startMouseX;
                const lengthDelta = mouseDelta * 2; // mm
                
                app.movementState.lengthEditData.pieces.forEach(piece => {
                    const editData = app.movementState.lengthEditData.pieceData.get(piece);
                    if (!editData) return;
                    
                    let newLength = editData.originalLength + (editData.editFace === 'top' ? lengthDelta : -lengthDelta);
                    newLength = Math.max(MIN_PIECE_LENGTH * 1000, newLength);
                    newLength = Math.round(newLength / 5) * 5; // Snap to 5mm
                    
                    applyLengthChange(piece, newLength, editData);
                });
                
                updateInfoPanel();
            } else if (app.mouseDown && !app.movementState.axis) {
                // Camera pan
                const panSpeed = 0.003 * app.cameraDistance / 3;
                const panVector = new THREE.Vector3();
                const camX = new THREE.Vector3().setFromMatrixColumn(app.camera.matrixWorld, 0);
                panVector.addScaledVector(camX, -deltaX * panSpeed);
                const camY = new THREE.Vector3().setFromMatrixColumn(app.camera.matrixWorld, 1);
                panVector.addScaledVector(camY, deltaY * panSpeed);
                app.cameraTarget.add(panVector);
                updateCameraPosition();
            } else if (app.rightMouseDown) {
                // Camera orbit
                const orbitSpeed = 0.005;
                app.cameraTheta -= deltaX * orbitSpeed;
                app.cameraPhi -= deltaY * orbitSpeed;
                app.cameraPhi = Math.max(0.01, Math.min(Math.PI - 0.01, app.cameraPhi));
                updateCameraPosition();
            }
            
            app.lastMouseX = event.clientX;
            app.lastMouseY = event.clientY;
        }
        
        function onMouseUp(event) {
            if (event.button === 0) {
                app.mouseDown = false;
                
                if (app.movementState.isDragging) {
                    endMovement(true);
                }
                
                if (app.movementState.lengthEditData) {
                    // Finalize length changes
                    app.movementState.lengthEditData.pieces.forEach(piece => {
                        const editData = app.movementState.lengthEditData.pieceData.get(piece);
                        if (editData && piece.userData.currentPreviewLength) {
                            piece.userData.length = piece.userData.currentPreviewLength;
                            delete piece.userData.currentPreviewLength;
                            
                            // Recreate geometry with final length for both mesh and outline
                            const mesh = piece.getObjectByName('mesh');
                            const outline = piece.getObjectByName('outline');
                            
                            if (mesh && mesh.geometry) mesh.geometry.dispose();
                            if (outline && outline.geometry) outline.geometry.dispose();
                            
                            const t = piece.userData.thickness / 1000;
                            const w = piece.userData.width / 1000;
                            const l = piece.userData.length / 1000;
                            const newGeometry = createRoundedBoxGeometry(t, w, l, 0.003, 4);
                            
                            if (mesh) mesh.geometry = newGeometry;
                            if (outline) {
                                const newEdges = new THREE.EdgesGeometry(newGeometry);
                                outline.geometry = newEdges;
                            }
                        }
                    });
                    
                    // Clear resize indicators
                    app.movementState.lengthEditData.pieces.forEach(piece => {
                        removeResizeIndicator(piece);
                    });
                    app.movementState.lengthEditData = null;
                    
                    saveState();
                    saveCurrentProject();
                    checkCollisions();
                    updateProjectDetails();
                    hideMeasurement();
                }
            } else if (event.button === 2) {
                app.rightMouseDown = false;
            }
            
            if (!app.mouseDown && !app.rightMouseDown) {
                document.getElementById('canvas').classList.remove('grabbing');
            }
        }
        
        function onKeyDown(event) {
            trackActivity();
            const key = event.key.toLowerCase();
            
            // Handle input field focus
            if (document.activeElement && 
                document.activeElement.tagName === 'INPUT' && 
                document.activeElement.closest('.side-panel')) {
                if (key === 'enter') { 
                    if (app.isAddingProject && document.activeElement.classList.contains('new-project-name-input')) {
                        app.gui.confirmNewProject();
                    } else if (app.editingProjectName && document.activeElement.classList.contains('edit-project-name-input')) {
                        app.gui.confirmRenameProject(app.editingProjectName, document.activeElement.value);
                    }
                } else if (key === 'escape') { 
                    if (app.isAddingProject) app.gui.cancelNewProject();
                    if (app.editingProjectName) app.gui.cancelRenameProject(app.editingProjectName);
                }
                return; 
            }

            // Movement mode keys
            if (app.movementState.active && app.movementState.mode !== 'drag') {
                // Handle arrow keys
                if (key === 'arrowup' || key === 'arrowdown') {
                    event.preventDefault();
                    // Up arrow results in a positive stepSize, down arrow in a negative stepSize.
                    // This will cause movement towards higher or lower axis values respectively.
                    const stepSize = key === 'arrowup' ? 0.01 : -0.01; // 10mm steps
                    
                    if (app.movementState.lengthEditData) {
                        // Step length adjustment
                        app.movementState.lengthEditData.pieces.forEach(piece => {
                            const currentLength = piece.userData.currentPreviewLength || piece.userData.length;
                            // Length adjustment is effectively always positive change for up, negative for down relative to what it would do
                            // Here, stepSize is used to increase or decrease the length.
                            const newLength = Math.max(MIN_PIECE_LENGTH * 1000, currentLength + stepSize * 1000);
                            applyLengthChange(piece, newLength, app.movementState.lengthEditData.pieceData.get(piece));
                        });
                    } else if (app.movementState.axis) {
                        // Step movement
                        const movement = new THREE.Vector3();
                        // The stepSize (positive for up, negative for down) is added to the current offset.
                        // This will result in movement towards higher axis values for up arrow,
                        // and towards lower axis values for down arrow.
                        movement[app.movementState.axis] = app.movementState.currentOffset[app.movementState.axis] + stepSize;
                        unifiedMove(app.selectedPieces, movement, 'step');
                    }
                    return;
                }
                
                // Handle typed input
                if ((key >= '0' && key <= '9') || key === '.' || key === '-') {
                    event.preventDefault();
                    if (key === '.' && app.movementState.typedValue.includes('.')) return;
                    if (key === '-' && app.movementState.typedValue.length > 0) return;
                    
                    app.movementState.typedValue += key;
                    updateTypedMeasurement();
                    return;
                }
                
                if (key === 'backspace') {
                    event.preventDefault();
                    if (app.movementState.typedValue.length > 0) {
                        app.movementState.typedValue = app.movementState.typedValue.slice(0, -1);
                        updateTypedMeasurement();
                    }
                    return;
                }
                
                if (key === 'enter') {
                    event.preventDefault();
                    applyTypedMeasurement();
                    return;
                }
            }
            
            app.keys[key] = true;
            
            // Global hotkeys
            if (key === 'g' && !event.repeat) {
                app.toggleGridSnap();
            }
            
            // Close menu with Escape key
            if (key === 'escape') {
                closeMenu();
            }
            
            // Zoom in/out with + and - keys
            if ((key === '+' || key === '=' || event.code === 'Equal') && !event.repeat) {
                // Zoom in
                const zoomFactor = 0.9; // 10% closer
                app.cameraDistance *= zoomFactor;
                app.cameraDistance = Math.max(0.5, Math.min(20, app.cameraDistance));
                updateCameraPosition();
                showStatus(`Zoom: ${Math.round((3 / app.cameraDistance) * 100)}%`, false, 1000);
            }
            
            if ((key === '-' || key === '_' || event.code === 'Minus') && !event.repeat) {
                // Zoom out
                const zoomFactor = 1.1; // 10% further
                app.cameraDistance *= zoomFactor;
                app.cameraDistance = Math.max(0.5, Math.min(20, app.cameraDistance));
                updateCameraPosition();
                showStatus(`Zoom: ${Math.round((3 / app.cameraDistance) * 100)}%`, false, 1000);
            }
            
            // Movement axis keys
            if (app.selectedPieces.size > 0 && !event.repeat) {
                if (key === 'z' || key === 'x' || key === 'c') {
                    const axis = key === 'z' ? 'z' : (key === 'x' ? 'x' : 'y');
                    if (!app.movementState.active) {
                        startMovement('key', axis);
                        showStatus(`${axis.toUpperCase()}-axis movement mode`);
                    }
                }
                
                // Rotation keys
                if (key === 'a') rotateSelected('localZ');
                else if (key === 's') rotateSelected('localX');
                else if (key === 'd') rotateSelected('localY');
            }
            
            // Delete key
            if (key === 't' && app.selectedPieces.size > 0) {
                deleteSelectedPieces();
            }
            
            // Undo/Redo
            if (event.ctrlKey) {
                if (key === 'z') { event.preventDefault(); undo(); }
                else if (key === 'y') { event.preventDefault(); redo(); }
            }
            
            // Quick material selection
            const numKey = parseInt(event.key);
            if (!isNaN(numKey) && numKey >= 0 && numKey <= 9 && 
                !app.movementState.active && !app.movementState.lengthEditData) {
                const index = numKey === 0 ? 9 : numKey - 1;
                if (app.recentDimensions[index]) {
                    const [thickness, width] = app.recentDimensions[index].split('x').map(Number);
                    selectWoodDimension(thickness, width);
                }
            }
        }
        
        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            delete app.keys[key];
            
            // End movement mode when axis key is released
            if ((key === 'z' || key === 'x' || key === 'c') && 
                app.movementState.active && 
                app.movementState.mode === 'key') {
                const axis = key === 'z' ? 'z' : (key === 'x' ? 'x' : 'y');
                if (app.movementState.axis === axis) {
                    endMovement(true);
                }
            }
        }
        
        function onMouseWheel(event) {
            if (event.target.id !== 'canvas' && !document.getElementById('sidePanel').contains(event.target)) {
                return;
            }
            if (document.getElementById('sidePanel').contains(event.target) && 
                document.getElementById('sidePanel').scrollHeight > document.getElementById('sidePanel').clientHeight) {
                return;
            }

            event.preventDefault();
            trackActivity();
            const zoomSpeed = 0.1;
            app.cameraDistance *= (1 + event.deltaY * -zoomSpeed * 0.01);
            app.cameraDistance = Math.max(0.5, Math.min(20, app.cameraDistance));
            updateCameraPosition();
        }
        
        function updateMouse(event) {
            app.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            app.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        
        function updateTypedMeasurement() {
            const measurement = app.measurementElement;
            measurement.classList.add('typing');
            
            let value = parseFloat(app.movementState.typedValue) || 0;
            let text = `${app.movementState.typedValue || '0'}mm`;
            
            if (app.movementState.lengthEditData) {
                text = `Length: ${text}`;
                if (app.movementState.lengthEditData.pieces.size > 1) {
                    text += ` (${app.movementState.lengthEditData.pieces.size} pieces)`;
                }
            } else if (app.movementState.axis) {
                text = `${app.movementState.axis.toUpperCase()}: ${text}`;
            }
            
            showMeasurement(text);
            
            // Update position
            const center = new THREE.Vector3();
            const pieces = app.movementState.lengthEditData ? 
                app.movementState.lengthEditData.pieces : app.selectedPieces;
            pieces.forEach(p => center.add(p.position));
            center.divideScalar(pieces.size);
            updateMeasurementPosition(center);
        }

        function applyTypedMeasurement() {
            const value = parseFloat(app.movementState.typedValue);
            if (isNaN(value)) return;
            
            if (app.movementState.lengthEditData) {
                // Apply typed length
                const lengthMM = Math.max(MIN_PIECE_LENGTH * 1000, Math.abs(value));
                app.movementState.lengthEditData.pieces.forEach(piece => {
                    const editData = app.movementState.lengthEditData.pieceData.get(piece);
                    if (editData) {
                        applyLengthChange(piece, lengthMM, editData);
                    }
                });
            } else if (app.movementState.axis) {
                // Apply typed movement
                const movement = new THREE.Vector3();
                movement[app.movementState.axis] = value / 1000; // Convert mm to meters
                unifiedMove(app.selectedPieces, movement, 'typed');
            }
            
            app.movementState.typedValue = '';
            app.measurementElement.classList.remove('typing');
        }
        
        function applyLengthChange(piece, newLengthMM, editData) {
            const snappedLength = Math.round(newLengthMM / 5) * 5; // Snap to nearest 5mm
            piece.userData.currentPreviewLength = snappedLength;

            const mesh = piece.getObjectByName('mesh');
            const outline = piece.getObjectByName('outline');

            if (mesh && mesh.geometry) mesh.geometry.dispose();
            if (outline && outline.geometry) outline.geometry.dispose();

            const t = piece.userData.thickness / 1000;
            const w = piece.userData.width / 1000;
            const l = snappedLength / 1000; // Use the new snapped preview length

            const newGeometry = createRoundedBoxGeometry(t, w, l, 0.003, 4);
            if (mesh) {
                mesh.geometry = newGeometry;
            }
            if (outline) {
                const newEdges = new THREE.EdgesGeometry(newGeometry);
                outline.geometry = newEdges;
            }

            const lengthChange = snappedLength - editData.originalLength;
            const shiftDistance = lengthChange / 2000;

            const localShiftAxis = new THREE.Vector3(0, 0, editData.editFace === 'top' ? 1 : -1);
            const worldShift = localShiftAxis.clone()
                .multiplyScalar(shiftDistance)
                .applyQuaternion(editData.originalQuaternion);

            piece.position.copy(editData.originalPosition).add(worldShift);
            piece.updateMatrixWorld(true); // IMPORTANT: Update matrix before bounds check

            // Floor constraint
            // With the fix in getAlignedBounds, 'bounds' will now use currentPreviewLength
            const bounds = GridSnapSystem.getAlignedBounds(piece);
            if (bounds.min.z < -FLOAT_PRECISION) {
                piece.position.z += (-bounds.min.z); // Shift entire piece up
                // Optional: Snap Z to grid after floor correction
                // piece.position.z = GridSnapSystem.snapToGrid(piece.position.z);
                piece.updateMatrixWorld(true); // Update matrix again if position changed
            }

            // Refresh the resize indicator (as per previous fix)
            createResizeIndicator(piece, editData.editFace);

            showMeasurement(`Length: ${snappedLength}mm`);
        }
        
        function rotateSelected(rotationType) {
            if (app.selectedPieces.size === 0) return;
            
            const center = new THREE.Vector3();
            app.selectedPieces.forEach(piece => center.add(piece.position));
            center.divideScalar(app.selectedPieces.size);
            
            const rotationAngle = Math.PI / 2;

            app.selectedPieces.forEach(piece => {
                // Apply local rotation
                if (rotationType === 'localX') piece.rotateX(rotationAngle);
                else if (rotationType === 'localY') piece.rotateY(rotationAngle);
                else if (rotationType === 'localZ') piece.rotateZ(rotationAngle);

                // If multiple pieces, rotate around group center
                if (app.selectedPieces.size > 1) {
                    const offset = piece.position.clone().sub(center);
                    let worldAxis = new THREE.Vector3();
                    if (rotationType === 'localX') worldAxis.set(1,0,0);
                    else if (rotationType === 'localY') worldAxis.set(0,1,0);
                    else if (rotationType === 'localZ') worldAxis.set(0,0,1);
                    
                    offset.applyAxisAngle(worldAxis, rotationAngle);
                    piece.position.copy(center).add(offset);
                }
                
                // Snap to grid and apply floor constraint using centralized bounds system
                piece.position.copy(snapVectorToGrid(piece.position));
                piece.updateMatrixWorld(true);
                const bounds = GridSnapSystem.getAlignedBounds(piece);
                if (bounds.min.z < 0) {
                    piece.position.z += -bounds.min.z;
                    piece.position.z = snapToGrid(piece.position.z);
                }
            });
            
            checkCollisions();
            
            // Check for collisions after rotation
            let hasCollisions = false;
            app.selectedPieces.forEach(piece => {
                if (piece.userData.isColliding) hasCollisions = true;
            });
            
            if (hasCollisions) {
                showStatus("⚠️ Rotation caused collisions! Use Ctrl+Z to undo if needed.", true, 4000);
            }

            saveState();
            saveCurrentProject();
            updateInfoPanel();
            updateProjectDetails();
            showStatus(`Rotated around ${rotationType}`);
        }

        function duplicatePiece(original) {
            const clone = createUnifiedWoodPiece(
                original.userData.thickness,
                original.userData.width,
                original.userData.length
            );
            
            // Copy position and rotation
            clone.position.copy(original.position);
            clone.quaternion.copy(original.quaternion);
            
            const offset = new THREE.Vector3(0.1, 0.1, 0.1);
            const preferredPosition = original.position.clone().add(offset);
            
            GridSnapSystem.findSafePosition(clone, preferredPosition);
            
            clearSelection();
            app.selectedPieces.add(clone);
            updatePieceSelection(clone, true);
            
            saveState();
            saveCurrentProject();
            updateHotkeyGuide();
            updateInfoPanel();
            updateProjectDetails();
            checkCollisions();
            showStatus('Duplicated piece');
        }

        function deleteSelectedPieces() {
            if (app.selectedPieces.size === 0) return;
            
            saveState();
            app.selectedPieces.forEach(piece => {
                app.scene.remove(piece);
                
                // Dispose of geometries and materials for both mesh and outline
                const mesh = piece.getObjectByName('mesh');
                const outline = piece.getObjectByName('outline');
                
                if (mesh) {
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) mesh.material.dispose();
                }
                
                if (outline) {
                    if (outline.geometry) outline.geometry.dispose();
                    if (outline.material) outline.material.dispose();
                }
                
                // Clean up any resize indicators
                removeResizeIndicator(piece);
            });
            
            const count = app.selectedPieces.size;
            app.selectedPieces.clear();
            saveCurrentProject();
            updateHotkeyGuide();
            updateInfoPanel();
            updateProjectDetails();
            checkCollisions();
            showStatus(`Deleted ${count} piece${count > 1 ? 's' : ''}`);
        }

        function clearSelection() {
            app.selectedPieces.forEach(piece => updatePieceSelection(piece, false));
            app.selectedPieces.clear();
        }

        function updatePieceSelection(piece, selected) {
            piece.userData.isSelected = selected;
            updatePieceAppearance(piece);
        }
        
        function showMeasurement(text) {
            const measurement = app.measurementElement;
            measurement.textContent = text;
            measurement.classList.remove('hidden');
            clearTimeout(app.measurementTimeout);
            app.measurementTimeout = setTimeout(() => measurement.classList.add('hidden'), 3000);
        }

        function hideMeasurement() {
            app.measurementElement.classList.add('hidden');
            clearTimeout(app.measurementTimeout);
        }

        function updateMeasurementPosition(worldPosition) {
            if (!worldPosition) return;
            const screenPosition = worldPosition.clone().project(app.camera);
            const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;
            app.measurementElement.style.left = `${x}px`;
            app.measurementElement.style.top = `${y}px`;
            app.measurementElement.style.transform = 'translate(-50%, -150%)';
        }
        
        function updateHotkeyGuide() {
            document.getElementById('movementGuide').style.display = app.movementState.active ? 'block' : 'none';
            document.getElementById('selectedGuide').style.display = 
                !app.movementState.active && !app.movementState.lengthEditData && app.selectedPieces.size > 0 ? 'block' : 'none';
            document.getElementById('lengthEditGuide').style.display = app.movementState.lengthEditData ? 'block' : 'none';
        }
        
        function loadProjects() {
            try {
                const saved = localStorage.getItem('woodProjects');
                app.projects = saved ? JSON.parse(saved) : { 'Project 1': { pieces: [] } };
            } catch (e) {
                console.error('Failed to parse projects:', e);
                app.projects = { 'Project 1': { pieces: [] } };
            }
            
            if (Object.keys(app.projects).length === 0) {
                app.projects = { 'Project 1': { pieces: [] } };
            }
            
            const projectNames = Object.keys(app.projects);
            if (projectNames.length > 0 && !app.currentProject) {
                loadProject(projectNames[0]);
            }
            
            app.gui.updateProjectList();
        }

        function saveCurrentProject() {
            if (!app.currentProject) return;
            
            try {
                const pieces = [];
                app.scene.traverse((obj) => {
                    if (obj.userData.isWoodPiece) {
                        pieces.push({
                            thickness: obj.userData.thickness,
                            width: obj.userData.width,
                            length: obj.userData.length,
                            position: obj.position.toArray(),
                            rotation: [obj.quaternion.x, obj.quaternion.y, obj.quaternion.z, obj.quaternion.w],
                            id: obj.userData.id
                        });
                    }
                });
                app.projects[app.currentProject] = { pieces };
                localStorage.setItem('woodProjects', JSON.stringify(app.projects));
            } catch (e) {
                console.error('Failed to save project:', e);
            }
        }

        function loadProject(name) {
            if (!app.projects[name]) {
                console.error('Project not found:', name);
                return;
            }
            
            if (app.currentProject) saveCurrentProject();
            
            clearSelection();
            
            const toRemove = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece) toRemove.push(obj);
            });
            toRemove.forEach(obj => {
                app.scene.remove(obj);
                
                // Properly dispose of integrated piece resources
                const mesh = obj.getObjectByName('mesh');
                const outline = obj.getObjectByName('outline');
                
                if (mesh) {
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) mesh.material.dispose();
                }
                
                if (outline) {
                    if (outline.geometry) outline.geometry.dispose();
                    if (outline.material) outline.material.dispose();
                }
            });
            
            const project = app.projects[name];
            if (project && project.pieces) {
                project.pieces.forEach(data => {
                    const piece = createUnifiedWoodPiece(data.thickness, data.width, data.length);
                    
                    // Ensure each loaded piece has a unique ID
                    const pieceId = data.id || ('piece_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
                    piece.userData.id = pieceId;
                    
                    piece.position.fromArray(data.position);
                    piece.quaternion.fromArray(data.rotation);
                });
            }
            
            app.currentProject = name;
            app.gui.updateProjectList();
            showStatus(`Loaded ${name}`);
            app.undoStack = [];
            app.redoStack = [];
            saveState();
            checkCollisions();
            updateInfoPanel();
            updateProjectDetails();
        }

        // Project GUI Management
        app.gui.currentNewProjectInput = null;
        app.gui.currentEditProjectInput = null;
        app.gui.originalEditName = null;

        app.gui.promptNewProject = function() {
            if (app.isAddingProject || app.editingProjectName) {
                app.gui.cancelActiveInput();
            }
            app.isAddingProject = true;

            const projectList = document.getElementById('projectList');
            const tempItem = document.createElement('div');
            tempItem.className = 'project-item new-project-input-item';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'New Project Name...';
            input.className = 'new-project-name-input';
            
            const confirmBtn = document.createElement('button');
            confirmBtn.className = 'confirm-new-project';
            confirmBtn.innerHTML = '<i class="fas fa-check"></i>';
            confirmBtn.title = "Confirm";
            confirmBtn.onclick = () => app.gui.confirmNewProject();
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'cancel-new-project';
            cancelBtn.innerHTML = '<i class="fas fa-times"></i>';
            cancelBtn.title = "Cancel";
            cancelBtn.onclick = () => app.gui.cancelNewProject();

            input.onkeydown = (e) => {
                if (e.key === 'Enter') app.gui.confirmNewProject();
                if (e.key === 'Escape') app.gui.cancelNewProject();
            };
            
            tempItem.appendChild(input);
            tempItem.appendChild(confirmBtn);
            tempItem.appendChild(cancelBtn);
            
            projectList.prepend(tempItem);
            input.focus();
            app.gui.currentNewProjectInput = tempItem;
        };

        app.gui.confirmNewProject = function() {
            if (!app.gui.currentNewProjectInput) return;
            const input = app.gui.currentNewProjectInput.querySelector('.new-project-name-input');
            const newName = input.value.trim();

            if (!newName) {
                showStatus("Project name cannot be empty.", true);
                input.focus();
                return;
            }
            if (app.projects[newName]) {
                showStatus("A project with this name already exists.", true);
                input.focus();
                return;
            }

            app.projects[newName] = { pieces: [] };
            if (app.currentProject) saveCurrentProject();
            loadProject(newName);
            app.gui.cancelNewProject();
            // Don't close menu - let user continue working with projects
            showStatus(`Created new project: ${newName}`);
        };

        app.gui.cancelNewProject = function() {
            if (app.gui.currentNewProjectInput) {
                app.gui.currentNewProjectInput.remove();
                app.gui.currentNewProjectInput = null;
            }
            app.isAddingProject = false;
        };
        
        app.gui.promptRenameProject = function(projectName, projectItemElement) {
            if (app.isAddingProject || app.editingProjectName) {
                app.gui.cancelActiveInput();
            }
            app.editingProjectName = projectName;
            app.gui.originalEditName = projectName;

            const nameSpan = projectItemElement.querySelector('.project-name');
            const actionsDiv = projectItemElement.querySelector('.project-actions');
            const deleteConfirmDiv = projectItemElement.querySelector('.project-delete-confirm');

            nameSpan.style.display = 'none';
            if(actionsDiv) actionsDiv.style.display = 'none';
            if(deleteConfirmDiv) deleteConfirmDiv.classList.remove('visible');

            let editForm = projectItemElement.querySelector('.project-edit-form');
            if (!editForm) {
                editForm = document.createElement('div');
                editForm.className = 'project-edit-form';
                projectItemElement.insertBefore(editForm, nameSpan.nextSibling);
            }
            
            editForm.innerHTML = `
                <input type="text" class="edit-project-name-input" value="${projectName}" style="width: calc(100% - 70px); margin-right: 5px;">
                <button class="confirm-edit-project" title="Confirm"><i class="fas fa-check"></i></button>
                <button class="cancel-edit-project" title="Cancel"><i class="fas fa-times"></i></button>
            `;
            editForm.style.display = 'flex';
            
            const input = editForm.querySelector('.edit-project-name-input');
            input.focus();
            input.select();

            editForm.querySelector('.confirm-edit-project').onclick = () => app.gui.confirmRenameProject(projectName, input.value);
            editForm.querySelector('.cancel-edit-project').onclick = () => app.gui.cancelRenameProject(projectName);
            input.onkeydown = (e) => {
                if (e.key === 'Enter') app.gui.confirmRenameProject(projectName, input.value);
                if (e.key === 'Escape') app.gui.cancelRenameProject(projectName);
            };
            app.gui.currentEditProjectInput = projectItemElement;
        };

        app.gui.confirmRenameProject = function(oldName, newNameRaw) {
            const newName = newNameRaw.trim();
            if (!newName) {
                showStatus("Project name cannot be empty.", true);
                const inputField = app.gui.currentEditProjectInput.querySelector('.edit-project-name-input');
                if(inputField) inputField.focus();
                return;
            }
            if (newName !== oldName && app.projects[newName]) {
                showStatus("A project with this name already exists.", true);
                const inputField = app.gui.currentEditProjectInput.querySelector('.edit-project-name-input');
                if(inputField) inputField.focus();
                return;
            }

            if (newName !== oldName) {
                app.projects[newName] = app.projects[oldName];
                delete app.projects[oldName];
                if (app.currentProject === oldName) {
                    app.currentProject = newName;
                }
                saveCurrentProject();
                localStorage.setItem('woodProjects', JSON.stringify(app.projects));
            }
            app.gui.cancelRenameProject(newName);
            app.gui.updateProjectList();
            showStatus(`Project renamed to ${newName}`);
        };

        app.gui.cancelRenameProject = function(projectNameToListUpdate) {
            if (app.gui.currentEditProjectInput) {
                const itemElement = app.gui.currentEditProjectInput;
                const nameSpan = itemElement.querySelector('.project-name');
                const actionsDiv = itemElement.querySelector('.project-actions');
                const editForm = itemElement.querySelector('.project-edit-form');

                if (nameSpan) nameSpan.style.display = 'block';
                if (actionsDiv) actionsDiv.style.display = 'flex';
                if (editForm) editForm.style.display = 'none';
            }
            app.editingProjectName = null;
            app.gui.originalEditName = null;
            app.gui.currentEditProjectInput = null;
        };
        
        app.gui.cancelActiveInput = function() {
            if (app.isAddingProject) {
                app.gui.cancelNewProject();
            }
            if (app.editingProjectName && app.gui.currentEditProjectInput) {
                const nameToRestore = app.gui.originalEditName || app.editingProjectName;
                const itemElement = app.gui.currentEditProjectInput;
                const nameSpan = itemElement.querySelector('.project-name');
                const actionsDiv = itemElement.querySelector('.project-actions');
                const editForm = itemElement.querySelector('.project-edit-form');

                if (nameSpan) nameSpan.style.display = 'block';
                if (actionsDiv) actionsDiv.style.display = 'flex';
                if (editForm) editForm.style.display = 'none';
                
                app.editingProjectName = null;
                app.gui.originalEditName = null;
                app.gui.currentEditProjectInput = null;
            }
        };
        
        app.gui.updateProjectList = function() {
            const projectList = document.getElementById('projectList');
            projectList.innerHTML = '';
            Object.keys(app.projects).sort().forEach(name => {
                const item = document.createElement('div');
                item.className = 'project-item';
                if (name === app.currentProject) item.classList.add('active');
                
                item.innerHTML = `
                    <span class="project-name" onclick="loadProject('${name}')">${name}</span>
                    <div class="project-actions">
                        <button onclick="app.gui.promptRenameProject('${name}', this.closest('.project-item'))" title="Rename">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button onclick="app.gui.promptDeleteProject('${name}', this.closest('.project-item'))" title="Delete">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                    <div class="project-delete-confirm">
                        <span>Delete "${name}"?</span>
                        <button class="confirm-yes" onclick="app.gui.deleteProject('${name}')" title="Confirm Delete">
                            <i class="fas fa-check"></i>
                        </button>
                        <button class="confirm-no" onclick="app.gui.cancelDeletePrompt(this.closest('.project-item'))" title="Cancel">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
                projectList.appendChild(item);
            });
        };
        
        app.gui.promptDeleteProject = function(projectName, projectItemElement) {
            if (app.isAddingProject || app.editingProjectName) {
                app.gui.cancelActiveInput();
            }
            const deleteConfirmDiv = projectItemElement.querySelector('.project-delete-confirm');
            deleteConfirmDiv.classList.add('visible');
        };
        
        app.gui.cancelDeletePrompt = function(projectItemElement) {
            const deleteConfirmDiv = projectItemElement.querySelector('.project-delete-confirm');
            deleteConfirmDiv.classList.remove('visible');
        };
        
        app.gui.deleteProject = function(projectName) {
            if (Object.keys(app.projects).length <= 1) {
                showStatus("Cannot delete the last project.", true);
                app.gui.cancelDeletePrompt(document.querySelector('.project-item'));
                return;
            }
            
            delete app.projects[projectName];
            localStorage.setItem('woodProjects', JSON.stringify(app.projects));
            
            if (app.currentProject === projectName) {
                const remaining = Object.keys(app.projects);
                if (remaining.length > 0) {
                    loadProject(remaining[0]);
                }
            }
            
            app.gui.updateProjectList();
            showStatus(`Deleted project: ${projectName}`);
        };
        
        function handleDocumentClickForInputs(event) {
            // Check if click is outside active inputs
            if (app.isAddingProject && app.gui.currentNewProjectInput) {
                if (!app.gui.currentNewProjectInput.contains(event.target) && 
                    !event.target.closest('.add-project-btn')) {
                    app.gui.cancelNewProject();
                }
            }
            
            if (app.editingProjectName && app.gui.currentEditProjectInput) {
                if (!app.gui.currentEditProjectInput.contains(event.target)) {
                    app.gui.cancelRenameProject(app.editingProjectName);
                }
            }
        }
        
        // Undo/Redo System
        function saveState() {
            const state = {
                pieces: [],
                camera: {
                    distance: app.cameraDistance,
                    theta: app.cameraTheta,
                    phi: app.cameraPhi,
                    target: app.cameraTarget.toArray()
                }
            };
            
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece) {
                    state.pieces.push({
                        thickness: obj.userData.thickness,
                        width: obj.userData.width,
                        length: obj.userData.length,
                        position: obj.position.toArray(),
                        rotation: [obj.quaternion.x, obj.quaternion.y, obj.quaternion.z, obj.quaternion.w],
                        id: obj.userData.id
                    });
                }
            });
            
            app.undoStack.push(state);
            if (app.undoStack.length > 50) app.undoStack.shift();
            app.redoStack = [];
        }
        
        function restoreState(state) {
            clearSelection();
            
            const toRemove = [];
            app.scene.traverse((obj) => {
                if (obj.userData.isWoodPiece) toRemove.push(obj);
            });
            toRemove.forEach(obj => {
                app.scene.remove(obj);
                
                // Properly dispose of integrated piece resources
                const mesh = obj.getObjectByName('mesh');
                const outline = obj.getObjectByName('outline');
                
                if (mesh) {
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) mesh.material.dispose();
                }
                
                if (outline) {
                    if (outline.geometry) outline.geometry.dispose();
                    if (outline.material) outline.material.dispose();
                }
            });
            
            state.pieces.forEach(data => {
                const piece = createUnifiedWoodPiece(data.thickness, data.width, data.length);
                
                const pieceId = data.id || ('piece_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
                piece.userData.id = pieceId;
                
                piece.position.fromArray(data.position);
                piece.quaternion.fromArray(data.rotation);
            });
            
            // Restore camera state
            app.cameraDistance = state.camera.distance;
            app.cameraTheta = state.camera.theta;
            app.cameraPhi = state.camera.phi;
            app.cameraTarget.fromArray(state.camera.target);
            updateCameraPosition();
            
            checkCollisions();
            updateInfoPanel();
            updateProjectDetails();
        }
        
        function undo() {
            if (app.undoStack.length <= 1) {
                showStatus('Nothing to undo', true);
                return;
            }
            
            const currentState = app.undoStack.pop();
            app.redoStack.push(currentState);
            const previousState = app.undoStack[app.undoStack.length - 1];
            restoreState(previousState);
            saveCurrentProject();
            showStatus('Undo');
        }
        
        function redo() {
            if (app.redoStack.length === 0) {
                showStatus('Nothing to redo', true);
                return;
            }
            
            const redoState = app.redoStack.pop();
            app.undoStack.push(redoState);
            restoreState(redoState);
            saveCurrentProject();
            showStatus('Redo');
        }
        
        // Guide Lines System
        function updateGuideLines() {
            clearGuideLines();
            
            if (app.movementState.active && app.movementState.axis && app.selectedPieces.size > 0) {
                const center = new THREE.Vector3();
                app.selectedPieces.forEach(p => center.add(p.position));
                center.divideScalar(app.selectedPieces.size);
                
                // Create guide line along movement axis
                const lineLength = 20;
                const lineGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);
                
                if (app.movementState.axis === 'x') {
                    positions[0] = center.x - lineLength; positions[1] = center.y; positions[2] = center.z;
                    positions[3] = center.x + lineLength; positions[4] = center.y; positions[5] = center.z;
                } else if (app.movementState.axis === 'y') {
                    positions[0] = center.x; positions[1] = center.y - lineLength; positions[2] = center.z;
                    positions[3] = center.x; positions[4] = center.y + lineLength; positions[5] = center.z;
                } else if (app.movementState.axis === 'z') {
                    positions[0] = center.x; positions[1] = center.y; positions[2] = Math.max(0, center.z - lineLength);
                    positions[3] = center.x; positions[4] = center.y; positions[5] = center.z + lineLength;
                }
                
                lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const lineMaterial = new THREE.LineDashedMaterial({
                    color: 0x4fc3f7,
                    linewidth: 1,
                    dashSize: 0.1,
                    gapSize: 0.05,
                    opacity: 0.6,
                    transparent: true
                });
                
                const line = new THREE.Line(lineGeometry, lineMaterial);
                line.computeLineDistances();
                line.userData.isGuideLine = true;
                app.scene.add(line);
                app.guideLines.push(line);
            }
        }
        
        function clearGuideLines() {
            app.guideLines.forEach(line => {
                app.scene.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            app.guideLines = [];
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update measurement position if visible
            if (!app.measurementElement.classList.contains('hidden') && app.selectedPieces.size > 0) {
                const center = new THREE.Vector3();
                app.selectedPieces.forEach(p => center.add(p.position));
                center.divideScalar(app.selectedPieces.size);
                updateMeasurementPosition(center);
            }
            
            app.renderer.render(app.scene, app.camera);
        }
        
        // Initialize the application
        init();
    </script>
</body>
</html>
